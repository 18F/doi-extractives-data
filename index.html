<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>USEITI Data: MVP</title>
    <script src="js/vendor/d3.v3.min.js"></script>
    <script src="js/vendor/queue.v1.min.js"></script>
    <script src="js/vendor/topojson.v1.min.js"></script>
    <script src="js/vendor/colorbrewer.js"></script>
    <script src="lib/albers-custom.js"></script>
    <script src="js/progressive.js"></script>
    <link rel="stylesheet" href="css/index.css">
  </head>
  <body>

    <section id="maps">
    </section>

    <section id="states">
    </section>

    <svg id="symbols">
    </svg>

    <footer>
      <div id="slider">
        <figure id="revenues-over-time" class="chart">
          <h6 class="chart__title">National Revenues Over Time</h6>
          <svg>
          </svg>
        </figure>
        <div id="slider-container">
          <input id="year-slider" type="range" min="2004" max="2013" step="1">
        </div>
      </div>

      <div id="progress">
        <div class="bar"><span class="label"></span></div>
      </div>
    </footer>

    <script>
(function(exports) {

  var data = exports.data = {};

  var prog = progressive();

  d3.select('#progress')
    .call(progressive.bar(prog));

  console.log('loading...');
  var dataPath = 'output/';
  queue()
    .defer(prog, d3.tsv, dataPath + 'state/revenues-2013.tsv')
    .defer(prog, d3.json, dataPath + 'geo/us-states.json')
    .await(function(error, stateRevenues, topology) {
      if (error) return console.error(error.responseText);

      data.revenues = {
        state: stateRevenues
      };

      console.time('topology');
      var states = topology.objects.states;
      data.geo = {
        states: {
          topology: topology,
          features: topojson.feature(topology, states).features,
          mesh: topojson.mesh(topology, states)
        }
      };
      console.timeEnd('topology');

      console.log('loaded!', data);
      loaded();

      location = location.hash;
    });

  function loaded() {
    var proj = d3.geo.albersCustom();

    var path = d3.geo.path()
      .projection(proj);

    var size = proj.size ? proj.size() : [960, 500];

    var symbols = d3.select('svg#symbols');
    var defs = symbols.append('defs');
    var mesh = defs.append('path')
      .attr('id', 'states-mesh')
      .attr('class', 'mesh states')
      .attr('d', path(data.geo.states.mesh));

    var index = d3.nest()
      .key(getter('Commodity'))
      .key(getter('State'))
      .rollup(function(d) {
        return d3.sum(d, getter('Revenue'));
      })
      .map(data.revenues.state);

    var commodities = d3.entries(index);

    // filter out commodities with only one value
    commodities = commodities
      .filter(function(d) {
        return Object.keys(d.value).length > 1;
      });

    var scales = d3.scale.ordinal()
      .range(Object.keys(colorbrewer));

    var formatDollars = d3.format('$,.0f');
    var steps = 9;

    commodities.forEach(function(c) {
      var values = d3.values(c.value);
      c.extent = d3.extent(values);
      if (c.extent[0] === c.extent[1]) {
        c.extent[0] = 0;
      }
      // console.log(c.key, 'max:', c.max);
      var scaleKey = scales(c.key);
      c.scale = d3.scale.quantize()
        .domain(c.extent)
        .range(colorbrewer[scaleKey][steps]);
    });

    // console.log('commodities:', commodities);

    var div = d3.select('#maps')
      .selectAll('section.commodity')
      .data(commodities)
      .enter()
      .append('section')
        .attr('class', 'commodity')
        .attr('id', function(d) {
          return d.id = 'commodities/' + normalize(d.key);
        });

    div.append('h2')
      .attr('class', 'section__title')
      .append('a')
        .attr('href', function(d) { return '#' + d.id; })
        .text(function(d) { return d.key; });

    var legend = div.append('ol')
      .attr('class', 'legend');

    var item = legend.selectAll('li')
      .data(function(d) {
        var scale = d.scale;
        return scale.range().map(function(color) {
          return {
            color: color,
            extent: scale.invertExtent(color)
          };
        });
      })
      .enter()
      .append('li')
        .style('width', (100 / steps).toFixed(1) + '%')
        .style('border-color', function(d) {
          return d.color;
        })
        .append('span')
          .text(function(d) {
            return formatDollars(d.extent[0]);
          });

    var svg = div.append('svg')
      .attr('class', 'map')
      .attr('viewBox', [0, 0].concat(size).join(' '));

    var g = svg.append('g')
      .attr('class', 'features states');

    var states = data.geo.states.features;

    var feature = g.selectAll('path.state')
      .data(function(d) {
        var commodity = d.key;
        return states.map(function(feature) {
          var state = feature.properties.abbr;
          return {
            state: state,
            feature: feature,
            commodity: d,
            value: d.value[state] || 0
          };
        });
      })
      .enter()
      .append('path')
        .attr('class', 'state')
        .attr('id', function(d) {
          return 'state-feature-' + d.state;
        })
        .attr('d', function(d) {
          return path(d.feature);
        })
        .attr('fill', function(d) {
          return d.value
            ? d.commodity.scale(d.value)
            : '#fff';
        });

    feature.append('title')
      .text(function(d) {
        return [d.state, ': ', formatDollars(d.value)].join('');
      });

    svg.append('use')
      .attr('xlink:href', '#states-mesh');
  }

  function getter(key) {
    return function(d) {
      return d[key];
    };
  }

  function normalize(str) {
    return str.toLowerCase()
      .replace(/\s*&\s*/g, '-')
      .replace(/ /g, '_');
  }

})(this);
    </script>
  </body>
</html>
