<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>USEITI Data: MVP</title>
    <script src="js/vendor/d3.v3.min.js"></script>
    <script src="js/vendor/queue.v1.min.js"></script>
    <script src="js/vendor/topojson.v1.min.js"></script>
    <script src="js/vendor/colorbrewer.js"></script>
    <script src="lib/albers-custom.js"></script>
    <script src="js/progressive.js"></script>
    <script src="js/eiti.js"></script>
    <link rel="stylesheet" href="css/index.css">
  </head>
  <body>

    <section id="commodities" class="container">
    </section>

    <section id="states" class="container">
    </section>

    <svg id="symbols">
    </svg>

    <footer>
      <div class="container">
        <div id="slider">
          <figure id="national-revenues" class="chart">
            <h6 class="chart__title">National Revenues Over Time</h6>
            <svg class="area">
            </svg>
          </figure>
          <div id="slider-container">
            <label for="year-slider">Year:</label>
            <input id="year-slider" type="range" min="2003" max="2013" step="1">
          </div>
        </div>
      </div>

      <div id="progress">
        <div class="bar"><span class="label"></span></div>
      </div>
    </footer>

    <script>
(function(exports) {

  var data = exports.data = {};

  var prog = progressive();

  var groupCommodities = (function() {
    var other = 'Other Commodities';
    var groups = d3.set(['Coal', 'Oil', 'Gas', 'Oil & Gas', 'Geothermal', other]);
    var groupMap = {
      'Oil Shale': 'Oil'
    };
    return function(d) {
      var commodity = d.Commodity;
      d.ActualCommodity = commodity;
      if (!groups.has(commodity)) {
        d.Commodity = groupMap[commodity] || other;
      }
    };
  })();

  var commodityColors = {
    'Coal': 'YlOrBr',
    'Oil': 'Greys',
    'Gas': 'Purples',
    'Oil & Gas': 'RdPu',
    'Geothermal': 'OrRd',
    'Other Commodities': 'Blues'
  };

  d3.select('#progress')
    .call(progressive.bar(prog));

  console.log('loading...');
  console.time('load');
  var dataPath = 'output/';
  queue()
    .defer(prog, d3.tsv, dataPath + 'national/revenues-yearly.tsv')
    .defer(prog, d3.tsv, dataPath + 'state/revenues-2013.tsv')
    .defer(prog, d3.json, dataPath + 'geo/us-states-simple.json')
    .await(function(error, natlRevenues, stateRevenues, topology) {
      if (error) return console.error(error.responseText);
      console.timeEnd('load');

      natlRevenues.forEach(groupCommodities);
      stateRevenues.forEach(groupCommodities);

      data.revenues = {
        national: natlRevenues,
        state: stateRevenues
      };

      var states = topology.objects.states;
      data.geo = {
        states: {
          topology: topology,
          features: topojson.feature(topology, states).features,
          mesh: topojson.mesh(topology, states)
        }
      };

      console.log('loaded!', data);
      console.time('render');
      renderTimeline();
      renderCommodityMaps();
      console.timeEnd('render');

      eiti.util.jiggleHash();
      // if (location.hash) scrollTo(location.hash);
    });

  function renderTimeline() {
    var area = areaChart()
      .stacked(false);

    var svg = d3.select('#national-revenues svg')
      .call(area, data.revenues.national);

    var margin = area.margin();
    var offset = 8;
    d3.select('#slider-container')
      .style('margin-left', (margin.left - offset) + 'px')
      .style('margin-right', (margin.right - offset + 2) + 'px');

    var slider = d3.select('#year-slider')
      .on('change', hiliteYear)
      .each(hiliteYear);

    function hiliteYear() {
      var year = +this.value;
      svg.selectAll('.x .tick')
        .classed('hilite', function(y) {
          return y === year;
        });
    }
  }

  function renderCommodityMaps() {
    var proj = d3.geo.albersCustom();

    var path = d3.geo.path()
      .projection(proj);

    var size = proj.size ? proj.size() : [960, 500];

    var symbols = d3.select('svg#symbols');
    var defs = symbols.append('defs');
    var mesh = defs.append('path')
      .attr('id', 'states-mesh')
      .attr('class', 'mesh states')
      .attr('d', path(data.geo.states.mesh));

    var index = d3.nest()
      .key(getter('Commodity'))
      .key(getter('State'))
      .rollup(function(d) {
        return d3.sum(d, getter('Revenue'));
      })
      .map(data.revenues.state);

    var commodities = d3.entries(index);

    // filter out commodities with only one value
    commodities = commodities
      .filter(function(d) {
        return Object.keys(d.value).length > 1;
      })

    var formatDollars = d3.format('$,.0f');
    var steps = 9;

    commodities.forEach(function(c) {
      var values = d3.values(c.value);
      c.extent = d3.extent(values);
      if (c.extent[0] === c.extent[1]) {
        c.extent[0] = 0;
      }
      // console.log(c.key, 'max:', c.max);
      var scaleKey = commodityColors[c.key] || 'Spectral';
      c.scale = d3.scale.quantize()
        .domain(c.extent)
        .range(colorbrewer[scaleKey][steps]);
    });

    commodities.sort(function(a, b) {
      return d3.descending(a.extent[1], b.extent[1]);
    });

    // console.log('commodities:', commodities);

    var div = d3.select('#commodities')
      .selectAll('section.commodity')
      .data(commodities)
      .enter()
      .append('section')
        .attr('class', 'commodity')
        .attr('id', function(d) {
          return d.id = 'commodities/' + normalize(d.key);
        });

    div.append('h2')
      .attr('class', 'section__title')
      .append('a')
        .attr('href', function(d) { return '#' + d.id; })
        .text(function(d) { return d.key; });

    var legend = div.append('ol')
      .attr('class', 'legend');

    var item = legend.selectAll('li')
      .data(function(d) {
        var scale = d.scale;
        return scale.range().map(function(color) {
          return {
            color: color,
            extent: scale.invertExtent(color)
          };
        });
      })
      .enter()
      .append('li')
        .style('width', (100 / steps).toFixed(1) + '%')
        .style('border-color', function(d) {
          return d.color;
        })
        .append('span')
          .text(function(d) {
            return formatDollars(d.extent[0]);
          });

    var svg = div.append('svg')
      .attr('class', 'map')
      .attr('viewBox', [0, 0].concat(size).join(' '));

    var g = svg.append('g')
      .attr('class', 'features states');

    var states = data.geo.states.features;

    var feature = g.selectAll('path.state')
      .data(function(d) {
        var commodity = d.key;
        return states.map(function(feature) {
          var state = feature.properties.abbr;
          return {
            state: state,
            feature: feature,
            commodity: d,
            value: d.value[state] || 0
          };
        });
      })
      .enter()
      .append('path')
        .attr('class', 'state')
        .attr('id', function(d) {
          return 'state-feature-' + d.state;
        })
        .attr('d', function(d) {
          return path(d.feature);
        })
        .attr('fill', function(d) {
          return d.value
            ? d.commodity.scale(d.value)
            : '#fff';
        });

    feature.append('title')
      .text(function(d) {
        return [d.state, ': ', formatDollars(d.value)].join('');
      });

    svg.append('use')
      .attr('xlink:href', '#states-mesh');
  }

  /*
   * an area chart generator:
   *
   * var chart = areaChart()
   *   .x(function(d) { return d.year; })
   *   .y(function(d) { return d.commodity; })
   *   .value(function(d) { return d.value; })
   *   .stacked(false);
   * var data = [
   *   {year: 2000, commodity: 'Coal', value: 10},
   *   {year: 2001, commodity: 'Coal', value: 20},
   *   // ...
   *   {year: 2010, commodity: 'Oil', value: 30},
   * ];
   * d3.select('svg').call(chart, data);
   */
  function areaChart() {
    var dx = getter('Year');
    var dy = getter('Commodity');
    var value = getter('Revenue');
    var stacked = true;
    var log = false;

    var width = 960;
    var height = 100;

    var margin = {
      top: 10,
      bottom: 25,
      left: 50,
      right: 20
    };

    var chart = function(svg, data) {
      if (data) {
        svg.datum(data);
      } else {
        data = svg.datum() || [];
      }
      svg.attr('viewBox', [0, 0, width, height].join(' '));

      var index = d3.nest()
        .key(dy)
        .key(dx)
        .rollup(function(d) {
          return d3.sum(d, value);
        })
        .map(data);

      var xs = d3.extent(data, dx).map(Number);
      var ys = d3.keys(index);
      var xd = d3.range(xs[0], xs[1] + 1);
      var layers = ys.map(function(y) {
        return xd.map(function(x) {
          var z = index[y][x] || 0;
          if (stacked && z < 0) z = 0;
          return {
            x: x,
            y: z,
            key: y
          };
        });
      });

      layers.forEach(function(d) {
        d.key = d[0].key;
        d.sum = d3.sum(d, getter('y'));
      });

      layers.sort(function(a, b) {
        return d3.descending(a.sum, b.sum);
      });

      var aggr = stacked ? d3.sum : d3.max;
      var yd = d3.extent(xd, function(x, i) {
        return aggr(layers, function(d) {
          return d[i].y;
        });
      });

      var y0 = height - margin.bottom;
      var y1 = margin.top;

      var y = log
        ? d3.scale.log()
          .domain([1, yd[1]])
          .range([y0, y1])
          .clamp(true)
        : d3.scale.linear()
          .domain([0, yd[1]])
          .range([y0, y1]);
      y.nice();

      var x = d3.scale.linear()
        .domain(d3.extent(data, dx))
        .range([margin.left, width - margin.right]);

      var yAxis = d3.svg.axis()
        .orient('left')
        .scale(y);

      var si = d3.format('s');
      var suffix = {K: 'k', M: 'm', G: 'b'};
      var ticks = 3;
      var yFormat = function(n, i) {
        var p = (i === 0 || i === ticks) ? '$' : '';
        return p + si(n).replace(/[KMG]$/, function(s) {
          return suffix[s] || s;
        });
      };
      if (log) {
        ticks -= 1;
        yAxis.ticks(ticks, yFormat);
      } else {
        yAxis.ticks(ticks)
          .tickFormat(yFormat);
      }

      svg.append('g')
        .attr('class', 'axis y')
        .attr('transform', 'translate(' + [margin.left - 2, 0] + ')')
        .call(yAxis);

      svg.append('g')
        .attr('class', 'axis x')
        .attr('transform', 'translate(' + [0, height - margin.bottom + 2] + ')')
        .call(d3.svg.axis()
          .orient('bottom')
          .scale(x)
          .tickFormat(d3.format('d')));

      var stack = d3.layout.stack();

      var g = svg.selectAll('g.layer')
        .data(stack(layers))
        .enter()
        .append('g')
          .attr('class', 'layer');

      var fill = function(key) {
        return colorbrewer[commodityColors[key]][5][3];
      };

      var area = d3.svg.area()
        .x(function(d) { return x(d.x); });

      if (stacked) {
        area
          .y0(function(d) { return y(d.y0); })
          .y1(function(d) { return y(d.y + d.y0); });
      } else {
        area
          .y0(y(0))
          .y1(function(d) { return y(d.y); });
      }

      var paths = g.append('path')
        .attr('fill', function(d) {
          return fill(d.key);
        })
        .attr('d', area);
    };

    chart.margin = function(_) {
      if (!arguments.length) return margin;
      margin = eiti.ui.margin(_);
      return chart;
    };

    chart.x = function(_) {
      if (!arguments.length) return dx;
      dx = (typeof _ === 'string')
        ? getter(_)
        : d3.functor(_);
      return chart;
    };

    chart.y = function(_) {
      if (!arguments.length) return dy;
      dy = (typeof _ === 'string')
        ? getter(_)
        : d3.functor(_);
      return chart;
    };

    chart.value = function(_) {
      if (!arguments.length) return value;
      value = (typeof _ === 'string')
        ? getter(_)
        : d3.functor(_);
      return chart;
    };

    chart.stacked = function(_) {
      if (!arguments.length) return stacked;
      stacked = !!_;
      return chart;
    };

    chart.log = function(_) {
      if (!arguments.length) return log;
      log = !!_;
      return chart;
    };

    return chart;
  }

  // create a getter function for a given property/key
  function getter(key) {
    return function(d) {
      return d[key];
    };
  }

  // normalize a string for use as a fragment identifier
  function normalize(str) {
    return str.toLowerCase()
      .replace(/\s*&\s*/g, '-')
      .replace(/ /g, '_');
  }

})(this);
    </script>
  </body>
</html>
