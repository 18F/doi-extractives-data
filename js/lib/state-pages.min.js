/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ function(module, exports, __webpack_require__) {

	(function(exports) {
	  'use strict';

	  __webpack_require__(24);
	  __webpack_require__(25);
	  __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./../components/data-map.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	  __webpack_require__(27);

	  __webpack_require__(4);
	  __webpack_require__(1);

	  var OpenListNav = __webpack_require__(23);

	  // exporting instance of OpenListNav because openListNav is
	  // referenced in the markup:
	  // _includes/hash_selecor.html
	  exports.openListNav = new OpenListNav();

	})(window);



/***/ },

/***/ 1:
/***/ function(module, exports) {

	(function(exports) {

	  var scrollLeft,
	    scrollTop;

	  var findScrollPositions = function(){
	    scrollLeft = (window.pageXOffset !== undefined)
	      ? window.pageXOffset
	      : (document.documentElement
	        || document.body.parentNode
	        || document.body).scrollLeft;
	    scrollTop = (window.pageYOffset !== undefined)
	      ? window.pageYOffset
	      : (document.documentElement
	        || document.body.parentNode
	        || document.body).scrollTop;

	  };

	  var StickyNav = function() {

	    this.elems = {
	      sticky : document.querySelector('.sticky_nav'),
	      main: document.querySelector('main')
	    };

	    this.attrStickyOffset = this.elems.sticky.getAttribute('data-sticky-offset');
	    this.attrOffsetBottom = parseInt(this.elems.sticky.getAttribute('data-offset-bottom')) || 0;
	    this.maxWidth = this.elems.sticky.getAttribute('data-max-width');
	    var attrAbsolute = this.elems.sticky.getAttribute('data-absolute');

	    this.attrParent = this.elems.sticky.getAttribute('data-offset-parent');

	    this.elems.parent = this.elems.sticky.getAttribute('data-offset-parent')
	      ? this.elems.sticky.parentNode
	      : null;

	    this.determineScreen = function() {
	      var windowWidth = window.innerWidth || document.body.clientWidth;
	      this.wasMobile = this.isMobile;
	      this.isMobile = windowWidth < 768;
	    };

	    this.determineScreen();

	    this.isAbsolute = function() {

	      var isAbsolute = (attrAbsolute === 'true' && !this.isMobile)
	        ? true
	        : false;
	      return isAbsolute;
	    }




	    this.status;
	    this.lastStatus;
	    this.lastWidth;
	    this.lastWindowWidth;
	  };

	  StickyNav.prototype = {
	    setOffset: function () {
	      this.offset = this.attrStickyOffset
	        ? parseInt(this.attrStickyOffset)
	        : !this.elems.parent
	          ? this.elems.sticky.offsetTop
	          : ( this.attrParent === 'mobile' && this.isMobile )
	            ? this.elems.parent.offsetTop - this.elems.sticky.offsetHeight
	            : this.elems.sticky.offsetTop
	    },
	    getPositions: function () {

	      this.height = this.elems.sticky.clientHeight;

	      this.lastWidth = this.width || 'initial';
	      var windowWidth = window.innerWidth || document.body.clientWidth,
	        windowBump = windowWidth > 1044 || this.isMobile ? 0 : -20;
	      this.width = this.elems.parent
	        ? this.elems.parent.clientWidth + windowBump + 'px'
	        : this.maxWidth;

	      this.mainOffset = this.elems.main.offsetTop;
	      this.mainHeight = this.elems.main.clientHeight;

	      this.diffTop = scrollTop - this.mainOffset - this.offset;

	      this.diffBottom = scrollTop + this.height - this.mainHeight - this.mainOffset;
	      this.lastStatus = this.status;
	      if (this.diffTop >= 0){
	        this.status = 'fixed';
	        if (this.diffBottom >= 0){
	          this.status = 'absolute';
	        }
	      } else {
	        this.status = 'static';
	      }
	    },
	    needsUpdate: function(init) {
	      var statusChange = this.status !== this.lastStatus;
	      var sizeChange = this.width !== this.lastWidth;
	      var updateNeeded = undefined;
	      if (!statusChange && sizeChange) {
	        updateNeeded = 'size';
	      } else if (statusChange && !sizeChange) {
	        updateNeeded = 'status';
	      } else if (statusChange && sizeChange || init === 'init') {
	        updateNeeded = 'both';
	      }
	      return updateNeeded;
	    },
	    update: function(updateNeeded) {
	      if (!updateNeeded) {
	        return;
	      } else {
	        if (this.diffTop >= 0){
	          if (updateNeeded === 'status' || updateNeeded === 'both') {
	            this.elems.sticky.style.position = 'fixed';
	            this.elems.sticky.style.top = 0;
	            this.elems.sticky.classList.remove('js-transparent');
	            this.elems.sticky.classList.add('js-color');
	          }

	          if (updateNeeded === 'size' || updateNeeded === 'both') {
	            this.elems.sticky.style.width = this.width;
	          }

	          if (this.diffBottom >= 0){
	            if (updateNeeded === 'status' || updateNeeded === 'both') {
	              this.elems.sticky.style.position = 'absolute';

	              if ( this.attrParent === 'mobile' && this.isMobile ) {
	                this.elems.sticky.style.top = this.mainHeight - this.offset - this.height - this.attrOffsetBottom + 'px';
	              } else {
	                this.elems.sticky.style.top = this.mainHeight - this.height - this.attrOffsetBottom + 'px';
	              }
	            }
	          }
	        } else {
	          if (updateNeeded === 'status' || updateNeeded === 'both') {
	            this.elems.sticky.classList.remove('js-color');
	            this.elems.sticky.classList.add('js-transparent');
	            if (this.isAbsolute()) {
	              this.elems.sticky.style.position = 'absolute';
	            } else {
	              this.elems.sticky.style.position = 'static';
	            }
	          }

	          if (updateNeeded === 'size' || updateNeeded === 'both') {
	            this.elems.sticky.style.width = this.width;
	          }
	        }
	      }
	    },
	    throttle : function (fn, threshhold, scope) {
	      threshhold || (threshhold = 250);
	      var last,
	          deferTimer;
	      return function () {
	        var context = scope || this;

	        var now = +new Date,
	            args = arguments;
	        if (last && now < last + threshhold) {
	          // hold on to it
	          clearTimeout(deferTimer);
	          deferTimer = setTimeout(function () {
	            last = now;
	            fn.apply(context, args);
	          }, threshhold);
	        } else {
	          last = now;
	          fn.apply(context, args);
	        }
	      };
	    },
	    run: function(init) {
	      findScrollPositions();
	      if (init === 'init') {
	        this.setOffset();
	      }
	      this.getPositions();
	      this.update(this.needsUpdate(init));
	    }
	  };

	  var stickyNav = new StickyNav();

	  var loadDelay = stickyNav.elems.sticky.getAttribute('data-load-delay');
	  if (loadDelay) {
	    setTimeout(function() {
	      stickyNav.run('init');
	    }, parseInt(loadDelay));
	  } else {
	    stickyNav.run('init');
	  }



	  window.addEventListener('scroll', stickyNav.throttle(stickyNav.run, 130, stickyNav));

	  window.addEventListener('resize', stickyNav.throttle(stickyNav.run, 150, stickyNav));

	  // documentation: https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
	  var observer = new MutationObserver(function () {
	    stickyNav.run();
	  });

	  // set up your configuration
	  // this will watch to see if you insert or remove any children
	  var config = { subtree: true, childList: true };

	  // start observing
	  observer.observe(stickyNav.elems.sticky, config);

	  // other potential elem listener
	  // http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/

	  exports.stickyNav = stickyNav;


	})(this);


/***/ },

/***/ 4:
/***/ function(module, exports) {

	$( document ).ready(function() {
	// ARIA Tab Interface
	// Thanks to Practical ARIA Examples
	// http://heydonworks.com/practical_aria_examples/#tab-interface

	// The class for the container div

	var $container = '.tab-interface';

	// The setup

	$($container +' ul').attr('role','tablist');
	$($container +' [role="tablist"] li').attr('role','presentation');
	$('[role="tablist"] a').attr({
	    'role' : 'tab',
	    'tabindex' : '-1'
	});

	// Make each aria-controls correspond id of targeted section (re href)

	$('[role="tablist"] a').each(function() {
	  $(this).attr(
	    'aria-controls', $(this).attr('href').substring(1)
	  );
	});

	// Make the first tab selected by default and allow it focus

	$('[role="tablist"] li:first-child a').attr({
	    'aria-selected' : 'true',
	    'tabindex' : '0'
	});

	// Make each section focusable and give it the tabpanel role

	$($container +' section').attr({
	  'role' : 'tabpanel'
	});

	// Make first child of each panel focusable programmatically

	$($container +' section > *:first-child').attr({
	    'tabindex' : '0'
	});

	// Make all but the first section hidden (ARIA state and display CSS)

	$('[role="tabpanel"]:not(:first-of-type)').attr({
	  'aria-hidden' : 'true'
	});

	// Change focus between tabs with arrow keys

	$('[role="tab"]').on('keydown', function(e) {

	  // define current, previous and next (possible) tabs

	  var $original = $(this);
	  var $prev = $(this).parents('li').prev().children('[role="tab"]');
	  var $next = $(this).parents('li').next().children('[role="tab"]');
	  var $target;

	  // find the direction (prev or next)

	  switch (e.keyCode) {
	    case 37:
	      $target = $prev;
	      break;
	    case 39:
	      $target = $next;
	      break;
	    default:
	      $target = false
	      break;
	  }

	  if ($target.length) {
	      $original.attr({
	        'tabindex' : '-1',
	        'aria-selected' : null
	      });
	      $target.attr({
	        'tabindex' : '0',
	        'aria-selected' : true
	      }).focus();
	  }

	  // Hide panels

	  $($container +' [role="tabpanel"]')
	    .attr('aria-hidden', 'true');

	  // Show panel which corresponds to target

	  $('#' + $(document.activeElement).attr('href').substring(1))
	    .attr('aria-hidden', null);

	});

	// Handle click on tab to show + focus tabpanel

	$('[role="tab"]').on('click', function(e) {

	  e.preventDefault();

	  // remove focusability [sic] and aria-selected

	  $('[role="tab"]').attr({
	    'tabindex': '-1',
	    'aria-selected' : null
	    });

	  // replace above on clicked tab

	  $(this).attr({
	    'aria-selected' : true,
	    'tabindex' : '0'
	  });

	  // Hide panels

	  $($container +' [role="tabpanel"]').attr('aria-hidden', 'true');

	  // show corresponding panel

	  $('#' + $(this).attr('href').substring(1))
	    .attr('aria-hidden', null);

	});

	});


/***/ },

/***/ 23:
/***/ function(module, exports) {

	(function(exports) {
	    function getScrollTop() {
	      return (window.pageYOffset !== undefined)
	        ? window.pageYOffset
	        : (document.documentElement
	          || document.body.parentNode
	          || document.body).scrollTop;
	    }



	    exports.OpenListNav = function() {
	      // init OpenListNav Properties
	      this.active = this.stripHash(window.location.hash) || 'intro';
	      this.navItems = document.querySelectorAll('[data-nav-item]');
	      this.navSelect = $('[data-nav-options]');
	      this.navIsSelect = !!this.navSelect.length;
	      // initialize at maximum value
	      this.defaultTop = 1e8;
	      this.closestToTop = this.defaultTop;
	      this.viewportElements = 0;
	      this.subnavItemClass = 'sticky_nav-nav_item-sub';
	      this.scrollTop = {
	        current: getScrollTop(),
	        prev: getScrollTop(),
	        direction: 'down'
	      };

	      this.registerEventHandlers();
	    };

	    exports.OpenListNav.prototype = {
	      updateScrollTop: function() {
	        this.scrollTop.prev = this.scrollTop.current;
	        this.scrollTop.current = getScrollTop();
	        this.scrollTop.direction = (this.scrollTop.current >= this.scrollTop.prev)
	          ? 'down'
	          : 'up';
	      },

	      isActiveElement: function(el) {
	        if (!el) {
	          return;
	        }

	        var status = false;
	        var rect = el.getBoundingClientRect();

	        var elementInViewport = rect.bottom > 0 &&
	            rect.right > 0 &&
	            rect.left < (window.innerWidth ||
	                         document.documentElement.clientWidth) &&
	            rect.top < (window.innerHeight ||
	                        document.documentElement.clientHeight);

	        var elTop = Math.abs(rect.top);

	        if (elementInViewport && (elTop < this.closestToTop) ) {
	          this.closestToTop = elTop;
	          this.viewportElements++;
	          status = true;
	        } else if (elementInViewport &&
	                  (this.viewportElements < 1) &&
	                  (elTop >= this.closestToTop) ) {
	          this.viewportElements++;
	          status = true;
	        }

	        return status;
	      },

	      stripHash: function (str) {
	        return str.charAt(0) === '#'
	          ? str.slice(1, str.length)
	          : str;
	      },

	      resetTop: function(){
	        this.closestToTop = this.defaultTop;
	        this.viewportElements = 0;
	      },

	      removeActive: function(){
	        this.active = null;
	        for (var i = 0; i < this.navItems.length; i++) {
	          this.navItems[i].setAttribute('data-active', false);
	        }
	      },

	      addActive: function(el, name, parent){
	        if (!el){
	          el = document.querySelector('[data-nav-item="' + name + '"]');
	          parent = document.querySelector('[data-nav-item="' + parent + '"]');
	          this.active = this.stripHash(name);
	          el.setAttribute('data-active', true);
	          if (parent) {
	            parent.setAttribute('data-active', true);
	          }

	        } else {
	          this.active = this.stripHash(el.getAttribute('data-nav-item'));
	          el.setAttribute('data-active', true);
	          if (parent) {
	            parent.setAttribute('data-active', true);
	          }
	        }
	      },

	      update: function(el, name, parent){
	        this.removeActive();
	        this.addActive(el, name, parent);
	      },

	      updateSelectField: function(newValue) {
	        if (newValue){
	          this.navSelect.val(newValue);
	        }
	      },

	      registerEventHandlers: function(){
	        var self = this;
	        if (!this.navIsSelect) {
	          for (var i = 0; i < this.navItems.length; i++) {
	            var item = this.navItems[i];
	            item.addEventListener('click', function () {
	              self.update(this);
	            });
	          }
	        }

	        window.addEventListener('scroll', function() {
	          self.updateScrollTop();
	          // TODO: throttle
	          self.detectNavChange();
	        });

	        window.addEventListener('resize', function(){
	          // TODO: throttle
	          self.detectNavChange();
	        });

	      },

	      changeHandler: function(selector) {
	        window.location.hash = selector.value;
	      },

	      detectNavChange: function(){

	        var self = this;

	        var items = this.navIsSelect
	          ? this.navSelect
	          : this.navItems;

	        Array.prototype.forEach.call(items, function(item){
	          var parentName,
	            newName,
	            header,
	            isActiveElement;

	          if (!self.navIsSelect) {
	            header = document.getElementById(item.dataset.navItem);

	            isActiveElement = self.isActiveElement(header);

	            if (isActiveElement) {
	              newName = header.id;

	              if (item.classList.contains(self.subnavItemClass)) {
	                parentName = item.parentElement.previousElementSibling
	                .getAttribute('data-nav-item');
	              }

	              self.update(null, newName, parentName);

	            }
	          } else if (self.navIsSelect) {
	            Array.prototype.forEach.call(item, function(option){

	              header = document.getElementById(option.value);
	              isActiveElement = self.isActiveElement(header);

	              if (isActiveElement && self.navIsSelect) {
	                newName = option.value;
	                self.updateSelectField(newName);
	              }
	            });
	          }

	        });

	        this.resetTop();
	      }
	    };

	    module.exports = exports.OpenListNav;
	  })(this);


/***/ },

/***/ 24:
/***/ function(module, exports) {

	(function(exports) {

	  var EXPANDED = 'aria-expanded';
	  var HIDDEN = 'aria-hidden';
	  var CONTROLS = 'aria-controls';

	  var toggle = function(button, expanded) {
	    if (arguments.length < 2 || typeof expanded !== 'boolean') {
	      expanded = button.getAttribute(EXPANDED) !== 'true';
	    }
	    var target = document.getElementById(button.getAttribute(CONTROLS));
	    button.setAttribute(EXPANDED, expanded);
	    target.setAttribute(HIDDEN, !expanded);
	  };

	  var click = function(event) {
	    toggle(event.target);
	  };

	  exports.ARIAToggle = document.registerElement('aria-toggle', {
	    'extends': 'button',
	    prototype: Object.create(
	      HTMLButtonElement.prototype,
	      {
	        attachedCallback: {value: function() {
	          if (this.hasAttribute(EXPANDED)) {
	            toggle(this, this.getAttribute(EXPANDED) === 'true');
	          }
	          this.addEventListener('click', click);
	        }},

	        detachedCallback: {value: function() {
	          this.removeEventListener('click', click);
	        }}
	      }
	    )
	  });

	})(this);


/***/ },

/***/ 25:
/***/ function(module, exports) {

	(function(exports) {

	  var initialize = function() {
	    this._cells = [].slice.call(this.querySelectorAll('tr > [data-value]'));
	    this.update();
	  };

	  var update = function() {
	    if (!this._cells.length) {
	      return;
	    }

	    var series = {};
	    var autolabel = this.getAttribute('autolabel') === 'true';

	    this._cells.forEach(function(cell) {
	      var key = cell.dataset.series || 'default';
	      if (key in series) {
	        series[key].push(cell);
	      } else {
	        series[key] = [cell];
	      }
	    });

	    Object.keys(series).forEach(function(key) {
	      var cells = series[key];
	      var values = cells.map(function(cell) {
	        return +cell.dataset.value;
	      });

	      var extent = d3.extent(values);
	      if (this.hasAttribute('data-' + key + '-min')) {
	        extent[0] = +this.dataset[key + 'Min'];
	      } else if (this.hasAttribute('data-min')) {
	        extent[0] = +this.dataset.min;
	      } else {
	        extent[0] = Math.min(extent[0], 0);
	      }

	      if (this.hasAttribute('data-' + key + '-max')) {
	        extent[1] = +this.dataset[key + 'Max'];
	      } else if (this.hasAttribute('data-max')) {
	        extent[1] = +this.dataset.max;
	      }

	      var range = [0, 100];
	      var min = extent[0];
	      var max = extent[1];
	      var negative = min < 0;
	      var zero = 0;
	      var width = d3.scale.linear()
	        .domain(extent)
	        .range(range)
	        .clamp(true);

	      var offset;
	      var sizeProperty = 'width';
	      var offsetProperty = 'margin-left';

	      if (negative) {
	        var length = max - min;
	        zero = 100 * (0 - min) / length;
	        offset = d3.scale.linear()
	          .domain([min, 0, max])
	          .range([0, zero, zero])
	          .clamp(true);
	        width = d3.scale.linear()
	          .domain([min, 0, max])
	          .range([100 * -min / length, 0, 100 * max / length])
	          .clamp(true);
	      }

	      if (this.orient === 'vertical') {
	        sizeProperty = 'height';
	        offsetProperty = 'bottom';
	      }

	      cells.forEach(function(cell, i) {
	        if (!cell) {
	          console.warn('no cell @', i);
	          return;
	        }

	        // TODO only do this if autolabel="true"?
	        if (cell.childNodes.length === 1 && cell.firstChild.nodeType === Node.TEXT_NODE) {
	          if (autolabel) {
	            cell.setAttribute('aria-label', cell.firstChild.textContent);
	            cell.removeChild(cell.firstChild);
	          } else {
	            var text = cell.removeChild(cell.firstChild);
	            var span = cell.appendChild(document.createElement('span'));
	            span.className = 'text';
	            span.appendChild(text);
	          }
	        }

	        var barExtent = cell.querySelector('.bar');
	        if (barExtent) {
	          var bar = barExtent.querySelector('.bar');
	        }

	        if (!barExtent && !bar) {
	          barExtent = document.createElement('div');
	          barExtent.className = 'bar';
	          bar = document.createElement('div');
	          bar.className = 'bar';
	          var span = cell.querySelector('span');
	          if (span && barExtent && bar) {
	            cell.insertBefore(barExtent,span);
	            barExtent.appendChild(bar);
	          }
	        }

	        var value = +cell.dataset.value;
	        var size = width(value);
	        bar.style.setProperty(sizeProperty, Math.abs(size) + '%');
	        if (offset) {
	          bar.style.setProperty(offsetProperty, offset(value) + '%');
	        } else {
	          bar.style.removeProperty(offsetProperty);
	        }
	      });

	    }, this);
	  };

	  exports.EITIBarChartTable = document.registerElement('bar-chart-table', {
	    'extends': 'table',
	    prototype: Object.create(
	      HTMLTableElement.prototype,
	      {
	        attachedCallback: {value: initialize},

	        attributeChangedCallback: {value: function(attr, old, value) {
	          switch (attr) {
	            case 'orient':
	              this.update();
	          }
	        }},

	        update: {value: update},

	        orient: {
	          get: function() {
	            return this.getAttribute('orient');
	          },
	          set: function(value) {
	            if (value !== this.orient) {
	              this.setAttribute('orient', value);
	            }
	          }
	        }
	      }
	    )
	  });

	})(this);


/***/ },
<<<<<<< a864744a1ad5f12609b0332ad91476dd3023ae26
=======
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	(function(exports) {

	  __webpack_require__(28);

	  var eiti = __webpack_require__(12);
	  var format = eiti.format;

	  exports.EITIDataMap = document.registerElement('data-map', {
	    prototype: Object.create(
	      HTMLElement.prototype,
	      {
	        attachedCallback: {value: function() {
	          this.update();
	        }},

	        update: {value: function() {
	          var type = this.getAttribute('scale-type') || 'quantize';
	          var scheme = this.getAttribute('color-scheme') || 'Blues';
	          var steps = this.getAttribute('steps') || 5;
	          var units = this.getAttribute('units') || '';

	          var stepDomain = [1, 9];

	          var colors = colorbrewer[scheme][steps];
	          if (!colors) {
	            return console.error(
	              'bad # of steps (%d) for color scheme:', steps, scheme
	            );
	          }

	          var marks = d3.select(this)
	            .selectAll('svg [data-value]')
	            .datum(function() {
	              return +this.getAttribute('data-value') || 0;
	            });

	          var domain = this.hasAttribute('domain')
	            ? JSON.parse(this.getAttribute('domain'))
	            : d3.extent(marks.data());

	          if (domain[0] > 0) {
	            domain[0] = 0;
	          } else if (domain[0] < 0) {
	            domain[1] = Math.max(0, domain[1]);
	          }

	          // FIXME: do something with divergent scales??

	          var scale = d3.scale[type]()
	            .domain(domain)
	            .range(colors);
>>>>>>> filter legend swatches

<<<<<<< 8a2fb60ffafab176a89c68b4dd0f47a610b0d7b4
<<<<<<< d0f4f2f84a4168c2bf8257b3aaef65c0dea59db6
/***/ 27:
=======
=======
	          var scaleSteps = d3.scale[type]()
	            .domain(stepDomain)
	            .range(colors);

>>>>>>> got rid of rounding issue
	          marks.attr('fill', scale);


	          // start map legend
	          function uniq(value, index, self) {
	            return self.indexOf(value) === index;
	          }

	          function getUnique(data, steps, domain) {
	            var getSteps = d3.scale[type]()
	              .domain(domain)
	              .range(steps);

	            var values = [];
	            data.forEach(function(d){
	              values.push(getSteps(d));
	            });

	            return values.filter(uniq);
	          }

	          var legend = d3.select(this)
	            .select(".legend-svg");

	          legend.append("g")
	            .attr("class", "legendScale");

	          var legendColor = d3.legend.color()
	            .labelFormat(format.si)
	            .useClass(false)
	            .ascending(true)
	            .labelDelimiter('-')
	            .shapePadding(6)
	            .scale(scale);

	          legend.select(".legendScale")
	            .call(legendColor);

	          // reverse because the scale is in ascending order
	          var _steps = d3.range(0,9).reverse();

	          // find which steps are represented in the map
	          var uniqueSteps = getUnique(marks.data(), _steps, domain);

	          // start consolidate (translate) visible cells
	          var cells = legend.selectAll('.cell')
	          var cellHeight = legendColor.shapeHeight() +
	            legendColor.shapePadding();
	          var count = 0;
	          cells.each(function(cell, i){
	            var present = uniqueSteps.indexOf(i) > -1;

	            if (!present) {
	              // hide cells swatches that aren't in the map
	              cells[0][i].setAttribute('aria-hidden', true);
	              count++
	            } else  {
	              // trim spacing between swatches that are visible
	              var translateHeight = (i * cellHeight) - (count * cellHeight)
	              cells[0][i].setAttribute('transform', 'translate(0,' + translateHeight + ')');
	            }
	          });
	          // end consolidation
	          // end map legend

	           // start trim height on map container
	           var svgContainer = d3.select(this)
	             .selectAll('.svg-container[data-dimensions]')
	             .datum(function() {
	               return (this.getBoundingClientRect().width
	                 * +this.getAttribute('data-dimensions')
	                 / 100)
	                 + 50;
	             });

	           function pixelize(d) {
	             return d + 'px';
	           }

	           svgContainer.style('padding-bottom', pixelize);
	           // end trim
	        }}
	      }
	    )
	  });

	})(this);


/***/ },
/* 27 */
>>>>>>> clean up padding hack with js
/***/ function(module, exports) {

	(function(exports) {

	  // symbols for "private" variables
	  var DATA = '__es_data__';
	  var SELECTED = '__es_selected__';

	  var observedAttributes = ['x-range', 'data', 'selected'];

	  // global dimensions
	  var width = 300;
	  var height = 100;
	  var dotRadius = 8;
	  var baseMargin = 16;
	  var margin = {
	    top: dotRadius + 1,
	    right: baseMargin,
	    bottom: baseMargin + dotRadius,
	    left: baseMargin
	  };

	  var left = margin.left;
	  var right = width - margin.right;
	  var top = margin.top;
	  var bottom = height - margin.bottom;

	  var attached = function() {
	    var svg = d3.select(this)
	      .append('svg')
	        .attr('viewBox', [0, 0, width, height].join(' '));
	    /*
	    svg.append('path')
	      .attr('class', 'data area');
	    */
	    svg.append('g')
	      .attr('class', 'axis x-axis');
	    svg.append('path')
	      .attr('class', 'data line');
	    svg.append('circle')
	      .attr('class', 'data point selected')
	      .attr('r', dotRadius);

	    observedAttributes.forEach(function(attr) {
	      if (this.hasAttribute(attr)) {
	        attributeChanged.call(this, attr, null, this.getAttribute(attr));
	      }
	    }, this);
	  };

	  var attributeChanged = function(name, previous, value) {
	    switch (name) {
	      case 'x-range':
	        this.xrange = JSON.parse(value);
	        break;
	      case 'data':
	        this.data = JSON.parse(value);
	        break;
	      case 'selected':
	        this.selected = value;
	        break;
	    }
	  };

	  var detached = function() {
	  };

	  var update = function() {
	    var data = this.data;
	    var values = data;

	    if (Array.isArray(data)) {
	      values = d3.nest()
	        .key(function(d) { return d.x; })
	        .rollup(function(d) { return d[0]; })
	        .entries(data);
	    } else {
	      values = Object.keys(data).reduce(function(map, key) {
	        map[key] = {x: +key, y: data[key]};
	        return map;
	      }, {});
	      data = Object.keys(data).map(function(key) {
	        return {x: +key, y: data[key]};
	      });
	    }

	    // console.log('data:', data, 'values:', values);

	    var xrange = this.xrange;
	    if (!xrange) {
	      xrange = d3.extent(data, function(d) { return +d.x; });
	    }

	    var xdomain = d3.range(xrange[0], xrange[1] + 1);
	    var x = d3.scale.linear()
	      .domain(xrange)
	      .range([left, right]);

	    xdomain.forEach(function(x) {
	      if (!values[x]) {
	        data.push({x: x, y: NaN});
	      }
	    });

	    var extent = d3.extent(data, function(d) { return d.y; });
	    var ymax = extent[1];
	    var ymin = extent[0]; // XXX 0?

	    var y = d3.scale.linear()
	      .domain([ymin, ymax])
	      .range([bottom, top]);

	    var svg = d3.select(this).select('svg');
	    var line = d3.svg.line()
	      .x(function(d) { return x(d.x); })
	      .y(function(d) { return y(d.y); })
	      .defined(function(d) {
	        return !isNaN(d.y);
	      });

	    data.sort(function(a, b) {
	      return d3.ascending(+a.x, +b.x);
	    });

	    svg.select('.line')
	      .datum(data)
	      .attr('d', line(data));

	    /*
	    var area = d3.svg.area()
	      .x(line.x())
	      .y0(bottom)
	      .y1(line.y());

	    svg.select('.area')
	      .datum(data)
	      .attr('d', area(data));
	    */

	    var x1 = xdomain[xdomain.length - 1];
	    var selected = this.selected || x1;
	    svg.select('.selected')
	      .datum(values)
	      .call(updateSelected, selected, x, y);

	    this.__x = x;
	    this.__y = y;

	    var axis = d3.svg.axis()
	      .orient('bottom')
	      .scale(x)
	      .ticks(xdomain.length)
	      .innerTickSize(-height)
	      .outerTickSize(0)
	      .tickPadding(dotRadius + 4)
	      .tickFormat(function(x) {
	        return String(x).substr(2);
	      });

	    svg.select('.x-axis')
	      .attr('transform', 'translate(' + [0, bottom] + ')')
	      .call(axis)
	      .selectAll('path, line')
	        .attr('fill', 'none');
	  };

	  var updateSelected = function(circle, value, x, y) {
	    circle
	      .attr('cx', function(d) {
	        return d[value] ? x(d[value].x) : x(value);
	      })
	      .attr('cy', function(d) {
	        return d[value] ? y(d[value].y) : y(0);
	      });
	  };

	  var EITILineChart = document.registerElement('eiti-line-chart', {
	    prototype: Object.create(
	      HTMLElement.prototype,
	      {
	        attachedCallback: {value: attached},
	        attributeChangedCallback: {value: attributeChanged},
	        detachedCallback: {value: detached},

	        update: {value: update},

	        data: {
	          get: function() {
	            return this[DATA];
	          },
	          set: function(data) {
	            this[DATA] = data;
	            this.update();
	          }
	        },

	        selected: {
	          get: function() {
	            return this[SELECTED];
	          },
	          set: function(x) {
	            this[SELECTED] = x;
	            if (this.__x && this.__y) {
	              d3.select(this)
	                .select('.selected')
	                  .call(updateSelected, x, this.__x, this.__y);
	            }
	          }
	        }
	      }
	    )
	  });

	  EITILineChart.observedAttributes = observedAttributes;

	  exports.EITILineChart = EITILineChart;

	})(this);


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var d3 = __webpack_require__(5);

	d3.legend = __webpack_require__(29);

	module.exports = d3;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  color: __webpack_require__(30),
	  size: __webpack_require__(32),
	  symbol: __webpack_require__(33)
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var helper = __webpack_require__(31);

	module.exports = function(){

	  var scale = d3.scale.linear(),
	    shape = "rect",
	    shapeWidth = 15,
	    shapeHeight = 15,
	    shapeRadius = 10,
	    shapePadding = 2,
	    cells = [5],
	    labels = [],
	    classPrefix = "",
	    useClass = false,
	    title = "",
	    labelFormat = d3.format(".01f"),
	    labelOffset = 10,
	    labelAlign = "middle",
	    labelDelimiter = "to",
	    orient = "vertical",
	    ascending = false,
	    path,
	    legendDispatcher = d3.dispatch("cellover", "cellout", "cellclick");

	    function legend(svg){

	      var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
	        legendG = svg.selectAll('g').data([scale]);

	      legendG.enter().append('g').attr('class', classPrefix + 'legendCells');


	      var cell = legendG.selectAll("." + classPrefix + "cell").data(type.data),
	        cellEnter = cell.enter().append("g", ".cell").attr("class", classPrefix + "cell").style("opacity", 1e-6);
	        shapeEnter = cellEnter.append(shape).attr("class", classPrefix + "swatch"),
	        shapes = cell.select("g." + classPrefix + "cell " + shape);

	      //add event handlers
	      helper.d3_addEvents(cellEnter, legendDispatcher);

	      cell.exit().transition().style("opacity", 0).remove();

	      helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, path);

	      helper.d3_addText(legendG, cellEnter, type.labels, classPrefix)

	      // sets placement
	      var text = cell.select("text"),
	        shapeSize = shapes[0].map( function(d){ return d.getBBox(); });

	      //sets scale
	      //everything is fill except for line which is stroke,
	      if (!useClass){
	        if (shape == "line"){
	          shapes.style("stroke", type.feature);
	        } else {
	          shapes.style("fill", type.feature);
	        }
	      } else {
	        shapes.attr("class", function(d){ return classPrefix + "swatch " + type.feature(d); });
	      }

	      var cellTrans,
	      textTrans,
	      textAlign = (labelAlign == "start") ? 0 : (labelAlign == "middle") ? 0.5 : 1;

	      //positions cells and text
	      if (orient === "vertical"){
	        cellTrans = function(d,i) { return "translate(0, " + (i * (shapeSize[i].height + shapePadding)) + ")"; };
	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width + shapeSize[i].x +
	          labelOffset) + "," + (shapeSize[i].y + shapeSize[i].height/2 + 5) + ")"; };

	      } else if (orient === "horizontal"){
	        cellTrans = function(d,i) { return "translate(" + (i * (shapeSize[i].width + shapePadding)) + ",0)"; }
	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width*textAlign  + shapeSize[i].x) +
	          "," + (shapeSize[i].height + shapeSize[i].y + labelOffset + 8) + ")"; };
	      }

	      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
	      helper.d3_title(svg, legendG, title, classPrefix);

	      cell.transition().style("opacity", 1);

	    }



	  legend.scale = function(_) {
	    if (!arguments.length) return scale;
	    scale = _;
	    return legend;
	  };

	  legend.cells = function(_) {
	    if (!arguments.length) return cells;
	    if (_.length > 1 || _ >= 2 ){
	      cells = _;
	    }
	    return legend;
	  };

	  legend.shape = function(_, d) {
	    if (!arguments.length) return shape;
	    if (_ == "rect" || _ == "circle" || _ == "line" || (_ == "path" && (typeof d === 'string')) ){
	      shape = _;
	      path = d;
	    }
	    return legend;
	  };

	  legend.shapeWidth = function(_) {
	    if (!arguments.length) return shapeWidth;
	    shapeWidth = +_;
	    return legend;
	  };

	  legend.shapeHeight = function(_) {
	    if (!arguments.length) return shapeHeight;
	    shapeHeight = +_;
	    return legend;
	  };

	  legend.shapeRadius = function(_) {
	    if (!arguments.length) return shapeRadius;
	    shapeRadius = +_;
	    return legend;
	  };

	  legend.shapePadding = function(_) {
	    if (!arguments.length) return shapePadding;
	    shapePadding = +_;
	    return legend;
	  };

	  legend.labels = function(_) {
	    if (!arguments.length) return labels;
	    labels = _;
	    return legend;
	  };

	  legend.labelAlign = function(_) {
	    if (!arguments.length) return labelAlign;
	    if (_ == "start" || _ == "end" || _ == "middle") {
	      labelAlign = _;
	    }
	    return legend;
	  };

	  legend.labelFormat = function(_) {
	    if (!arguments.length) return labelFormat;
	    labelFormat = _;
	    return legend;
	  };

	  legend.labelOffset = function(_) {
	    if (!arguments.length) return labelOffset;
	    labelOffset = +_;
	    return legend;
	  };

	  legend.labelDelimiter = function(_) {
	    if (!arguments.length) return labelDelimiter;
	    labelDelimiter = _;
	    return legend;
	  };

	  legend.useClass = function(_) {
	    if (!arguments.length) return useClass;
	    if (_ === true || _ === false){
	      useClass = _;
	    }
	    return legend;
	  };

	  legend.orient = function(_){
	    if (!arguments.length) return orient;
	    _ = _.toLowerCase();
	    if (_ == "horizontal" || _ == "vertical") {
	      orient = _;
	    }
	    return legend;
	  };

	  legend.ascending = function(_) {
	    if (!arguments.length) return ascending;
	    ascending = !!_;
	    return legend;
	  };

	  legend.classPrefix = function(_) {
	    if (!arguments.length) return classPrefix;
	    classPrefix = _;
	    return legend;
	  };

	  legend.title = function(_) {
	    if (!arguments.length) return title;
	    title = _;
	    return legend;
	  };

	  d3.rebind(legend, legendDispatcher, "on");

	  return legend;

	};


/***/ },
/* 31 */
/***/ function(module, exports) {

	module.exports = {

	  d3_identity: function (d) {
	    return d;
	  },

	  d3_mergeLabels: function (gen, labels) {

	      if(labels.length === 0) return gen;

	      gen = (gen) ? gen : [];

	      var i = labels.length;
	      for (; i < gen.length; i++) {
	        labels.push(gen[i]);
	      }
	      return labels;
	    },

	  d3_linearLegend: function (scale, cells, labelFormat) {
	    var data = [];

	    if (cells.length > 1){
	      data = cells;

	    } else {
	      var domain = scale.domain(),
	      increment = (domain[domain.length - 1] - domain[0])/(cells - 1),
	      i = 0;

	      for (; i < cells; i++){
	        data.push(domain[0] + i*increment);
	      }
	    }

	    var labels = data.map(labelFormat);

	    return {data: data,
	            labels: labels,
	            feature: function(d){ return scale(d); }};
	  },

	  d3_quantLegend: function (scale, labelFormat, labelDelimiter) {
	    var labels = scale.range().map(function(d){
	      var invert = scale.invertExtent(d),
	      a = labelFormat(invert[0]),
	      b = labelFormat(invert[1]);

	      // if (( (a) && (a.isNan()) && b){
	      //   console.log("in initial statement")
	        return labelFormat(invert[0]) + " " + labelDelimiter + " " + labelFormat(invert[1]);
	      // } else if (a || b) {
	      //   console.log('in else statement')
	      //   return (a) ? a : b;
	      // }

	    });

	    return {data: scale.range(),
	            labels: labels,
	            feature: this.d3_identity
	          };
	  },

	  d3_ordinalLegend: function (scale) {
	    return {data: scale.domain(),
	            labels: scale.domain(),
	            feature: function(d){ return scale(d); }};
	  },

	  d3_drawShapes: function (shape, shapes, shapeHeight, shapeWidth, shapeRadius, path) {
	    if (shape === "rect"){
	        shapes.attr("height", shapeHeight).attr("width", shapeWidth);

	    } else if (shape === "circle") {
	        shapes.attr("r", shapeRadius)//.attr("cx", shapeRadius).attr("cy", shapeRadius);

	    } else if (shape === "line") {
	        shapes.attr("x1", 0).attr("x2", shapeWidth).attr("y1", 0).attr("y2", 0);

	    } else if (shape === "path") {
	      shapes.attr("d", path);
	    }
	  },

	  d3_addText: function (svg, enter, labels, classPrefix){
	    enter.append("text").attr("class", classPrefix + "label");
	    svg.selectAll("g." + classPrefix + "cell text").data(labels).text(this.d3_identity);
	  },

	  d3_calcType: function (scale, ascending, cells, labels, labelFormat, labelDelimiter){
	    var type = scale.ticks ?
	            this.d3_linearLegend(scale, cells, labelFormat) : scale.invertExtent ?
	            this.d3_quantLegend(scale, labelFormat, labelDelimiter) : this.d3_ordinalLegend(scale);

	    type.labels = this.d3_mergeLabels(type.labels, labels);

	    if (ascending) {
	      type.labels = this.d3_reverse(type.labels);
	      type.data = this.d3_reverse(type.data);
	    }

	    return type;
	  },

	  d3_reverse: function(arr) {
	    var mirror = [];
	    for (var i = 0, l = arr.length; i < l; i++) {
	      mirror[i] = arr[l-i-1];
	    }
	    return mirror;
	  },

	  d3_placement: function (orient, cell, cellTrans, text, textTrans, labelAlign) {
	    cell.attr("transform", cellTrans);
	    text.attr("transform", textTrans);
	    if (orient === "horizontal"){
	      text.style("text-anchor", labelAlign);
	    }
	  },

	  d3_addEvents: function(cells, dispatcher){
	    var _ = this;

	      cells.on("mouseover.legend", function (d) { _.d3_cellOver(dispatcher, d, this); })
	          .on("mouseout.legend", function (d) { _.d3_cellOut(dispatcher, d, this); })
	          .on("click.legend", function (d) { _.d3_cellClick(dispatcher, d, this); });
	  },

	  d3_cellOver: function(cellDispatcher, d, obj){
	    cellDispatcher.cellover.call(obj, d);
	  },

	  d3_cellOut: function(cellDispatcher, d, obj){
	    cellDispatcher.cellout.call(obj, d);
	  },

	  d3_cellClick: function(cellDispatcher, d, obj){
	    cellDispatcher.cellclick.call(obj, d);
	  },

	  d3_title: function(svg, cellsSvg, title, classPrefix){
	    if (title !== ""){

	      var titleText = svg.selectAll('text.' + classPrefix + 'legendTitle');

	      titleText.data([title])
	        .enter()
	        .append('text')
	        .attr('class', classPrefix + 'legendTitle');

	        svg.selectAll('text.' + classPrefix + 'legendTitle')
	            .text(title)

	      var yOffset = svg.select('.' + classPrefix + 'legendTitle')
	          .map(function(d) { return d[0].getBBox().height})[0],
	      xOffset = -cellsSvg.map(function(d) { return d[0].getBBox().x})[0];

	      cellsSvg.attr('transform', 'translate(' + xOffset + ',' + (yOffset + 10) + ')');

	    }
	  }
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var helper = __webpack_require__(31);

	module.exports =  function(){

	  var scale = d3.scale.linear(),
	    shape = "rect",
	    shapeWidth = 15,
	    shapePadding = 2,
	    cells = [5],
	    labels = [],
	    useStroke = false,
	    classPrefix = "",
	    title = "",
	    labelFormat = d3.format(".01f"),
	    labelOffset = 10,
	    labelAlign = "middle",
	    labelDelimiter = "to",
	    orient = "vertical",
	    ascending = false,
	    path,
	    legendDispatcher = d3.dispatch("cellover", "cellout", "cellclick");

	    function legend(svg){

	      var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
	        legendG = svg.selectAll('g').data([scale]);

	      legendG.enter().append('g').attr('class', classPrefix + 'legendCells');


	      var cell = legendG.selectAll("." + classPrefix + "cell").data(type.data),
	        cellEnter = cell.enter().append("g", ".cell").attr("class", classPrefix + "cell").style("opacity", 1e-6);
	        shapeEnter = cellEnter.append(shape).attr("class", classPrefix + "swatch"),
	        shapes = cell.select("g." + classPrefix + "cell " + shape);

	      //add event handlers
	      helper.d3_addEvents(cellEnter, legendDispatcher);

	      cell.exit().transition().style("opacity", 0).remove();

	      //creates shape
	      if (shape === "line"){
	        helper.d3_drawShapes(shape, shapes, 0, shapeWidth);
	        shapes.attr("stroke-width", type.feature);
	      } else {
	        helper.d3_drawShapes(shape, shapes, type.feature, type.feature, type.feature, path);
	      }

	      helper.d3_addText(legendG, cellEnter, type.labels, classPrefix)

	      //sets placement
	      var text = cell.select("text"),
	        shapeSize = shapes[0].map(
	          function(d, i){
	            var bbox = d.getBBox()
	            var stroke = scale(type.data[i]);

	            if (shape === "line" && orient === "horizontal") {
	              bbox.height = bbox.height + stroke;
	            } else if (shape === "line" && orient === "vertical"){
	              bbox.width = bbox.width;
	            }

	            return bbox;
	        });

	      var maxH = d3.max(shapeSize, function(d){ return d.height + d.y; }),
	      maxW = d3.max(shapeSize, function(d){ return d.width + d.x; });

	      var cellTrans,
	      textTrans,
	      textAlign = (labelAlign == "start") ? 0 : (labelAlign == "middle") ? 0.5 : 1;

	      //positions cells and text
	      if (orient === "vertical"){

	        cellTrans = function(d,i) {
	            var height = d3.sum(shapeSize.slice(0, i + 1 ), function(d){ return d.height; });
	            return "translate(0, " + (height + i*shapePadding) + ")"; };

	        textTrans = function(d,i) { return "translate(" + (maxW + labelOffset) + "," +
	          (shapeSize[i].y + shapeSize[i].height/2 + 5) + ")"; };

	      } else if (orient === "horizontal"){
	        cellTrans = function(d,i) {
	            var width = d3.sum(shapeSize.slice(0, i + 1 ), function(d){ return d.width; });
	            return "translate(" + (width + i*shapePadding) + ",0)"; };

	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width*textAlign  + shapeSize[i].x) + "," +
	              (maxH + labelOffset ) + ")"; };
	      }

	      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
	      helper.d3_title(svg, legendG, title, classPrefix);

	      cell.transition().style("opacity", 1);

	    }

	  legend.scale = function(_) {
	    if (!arguments.length) return scale;
	    scale = _;
	    return legend;
	  };

	  legend.cells = function(_) {
	    if (!arguments.length) return cells;
	    if (_.length > 1 || _ >= 2 ){
	      cells = _;
	    }
	    return legend;
	  };


	  legend.shape = function(_, d) {
	    if (!arguments.length) return shape;
	    if (_ == "rect" || _ == "circle" || _ == "line" ){
	      shape = _;
	      path = d;
	    }
	    return legend;
	  };

	  legend.shapeWidth = function(_) {
	    if (!arguments.length) return shapeWidth;
	    shapeWidth = +_;
	    return legend;
	  };

	  legend.shapePadding = function(_) {
	    if (!arguments.length) return shapePadding;
	    shapePadding = +_;
	    return legend;
	  };

	  legend.labels = function(_) {
	    if (!arguments.length) return labels;
	    labels = _;
	    return legend;
	  };

	  legend.labelAlign = function(_) {
	    if (!arguments.length) return labelAlign;
	    if (_ == "start" || _ == "end" || _ == "middle") {
	      labelAlign = _;
	    }
	    return legend;
	  };

	  legend.labelFormat = function(_) {
	    if (!arguments.length) return labelFormat;
	    labelFormat = _;
	    return legend;
	  };

	  legend.labelOffset = function(_) {
	    if (!arguments.length) return labelOffset;
	    labelOffset = +_;
	    return legend;
	  };

	  legend.labelDelimiter = function(_) {
	    if (!arguments.length) return labelDelimiter;
	    labelDelimiter = _;
	    return legend;
	  };

	  legend.orient = function(_){
	    if (!arguments.length) return orient;
	    _ = _.toLowerCase();
	    if (_ == "horizontal" || _ == "vertical") {
	      orient = _;
	    }
	    return legend;
	  };

	  legend.ascending = function(_) {
	    if (!arguments.length) return ascending;
	    ascending = !!_;
	    return legend;
	  };

	  legend.classPrefix = function(_) {
	    if (!arguments.length) return classPrefix;
	    classPrefix = _;
	    return legend;
	  };

	  legend.title = function(_) {
	    if (!arguments.length) return title;
	    title = _;
	    return legend;
	  };

	  d3.rebind(legend, legendDispatcher, "on");

	  return legend;

	};


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var helper = __webpack_require__(31);

	module.exports = function(){

	  var scale = d3.scale.linear(),
	    shape = "path",
	    shapeWidth = 15,
	    shapeHeight = 15,
	    shapeRadius = 10,
	    shapePadding = 5,
	    cells = [5],
	    labels = [],
	    classPrefix = "",
	    useClass = false,
	    title = "",
	    labelFormat = d3.format(".01f"),
	    labelAlign = "middle",
	    labelOffset = 10,
	    labelDelimiter = "to",
	    orient = "vertical",
	    ascending = false,
	    legendDispatcher = d3.dispatch("cellover", "cellout", "cellclick");

	    function legend(svg){

	      var type = helper.d3_calcType(scale, ascending, cells, labels, labelFormat, labelDelimiter),
	        legendG = svg.selectAll('g').data([scale]);

	      legendG.enter().append('g').attr('class', classPrefix + 'legendCells');

	      var cell = legendG.selectAll("." + classPrefix + "cell").data(type.data),
	        cellEnter = cell.enter().append("g", ".cell").attr("class", classPrefix + "cell").style("opacity", 1e-6);
	        shapeEnter = cellEnter.append(shape).attr("class", classPrefix + "swatch"),
	        shapes = cell.select("g." + classPrefix + "cell " + shape);

	      //add event handlers
	      helper.d3_addEvents(cellEnter, legendDispatcher);

	      //remove old shapes
	      cell.exit().transition().style("opacity", 0).remove();

	      helper.d3_drawShapes(shape, shapes, shapeHeight, shapeWidth, shapeRadius, type.feature);
	      helper.d3_addText(legendG, cellEnter, type.labels, classPrefix)

	      // sets placement
	      var text = cell.select("text"),
	        shapeSize = shapes[0].map( function(d){ return d.getBBox(); });

	      var maxH = d3.max(shapeSize, function(d){ return d.height; }),
	      maxW = d3.max(shapeSize, function(d){ return d.width; });

	      var cellTrans,
	      textTrans,
	      textAlign = (labelAlign == "start") ? 0 : (labelAlign == "middle") ? 0.5 : 1;

	      //positions cells and text
	      if (orient === "vertical"){
	        cellTrans = function(d,i) { return "translate(0, " + (i * (maxH + shapePadding)) + ")"; };
	        textTrans = function(d,i) { return "translate(" + (maxW + labelOffset) + "," +
	              (shapeSize[i].y + shapeSize[i].height/2 + 5) + ")"; };

	      } else if (orient === "horizontal"){
	        cellTrans = function(d,i) { return "translate(" + (i * (maxW + shapePadding)) + ",0)"; };
	        textTrans = function(d,i) { return "translate(" + (shapeSize[i].width*textAlign  + shapeSize[i].x) + "," +
	              (maxH + labelOffset ) + ")"; };
	      }

	      helper.d3_placement(orient, cell, cellTrans, text, textTrans, labelAlign);
	      helper.d3_title(svg, legendG, title, classPrefix);
	      cell.transition().style("opacity", 1);

	    }


	  legend.scale = function(_) {
	    if (!arguments.length) return scale;
	    scale = _;
	    return legend;
	  };

	  legend.cells = function(_) {
	    if (!arguments.length) return cells;
	    if (_.length > 1 || _ >= 2 ){
	      cells = _;
	    }
	    return legend;
	  };

	  legend.shapePadding = function(_) {
	    if (!arguments.length) return shapePadding;
	    shapePadding = +_;
	    return legend;
	  };

	  legend.labels = function(_) {
	    if (!arguments.length) return labels;
	    labels = _;
	    return legend;
	  };

	  legend.labelAlign = function(_) {
	    if (!arguments.length) return labelAlign;
	    if (_ == "start" || _ == "end" || _ == "middle") {
	      labelAlign = _;
	    }
	    return legend;
	  };

	  legend.labelFormat = function(_) {
	    if (!arguments.length) return labelFormat;
	    labelFormat = _;
	    return legend;
	  };

	  legend.labelOffset = function(_) {
	    if (!arguments.length) return labelOffset;
	    labelOffset = +_;
	    return legend;
	  };

	  legend.labelDelimiter = function(_) {
	    if (!arguments.length) return labelDelimiter;
	    labelDelimiter = _;
	    return legend;
	  };

	  legend.orient = function(_){
	    if (!arguments.length) return orient;
	    _ = _.toLowerCase();
	    if (_ == "horizontal" || _ == "vertical") {
	      orient = _;
	    }
	    return legend;
	  };

	  legend.ascending = function(_) {
	    if (!arguments.length) return ascending;
	    ascending = !!_;
	    return legend;
	  };

	  legend.classPrefix = function(_) {
	    if (!arguments.length) return classPrefix;
	    classPrefix = _;
	    return legend;
	  };

	  legend.title = function(_) {
	    if (!arguments.length) return title;
	    title = _;
	    return legend;
	  };

	  d3.rebind(legend, legendDispatcher, "on");

	  return legend;

	};


/***/ }

/******/ });