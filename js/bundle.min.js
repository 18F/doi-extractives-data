/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	// // 3rd party dependencies
	// require("./vendor/d3.v3.min.js");
	// require("./vendor/colorbrewer.js");
	// require("./vendor/jquery.min.js");
	
	// // custom map projection
	// require("./albers-custom.js");
	
	// // EITI libs
	__webpack_require__(7);
	
	// // custom elements
	__webpack_require__(2);
	__webpack_require__(3);
	__webpack_require__(4);
	__webpack_require__(5);
	__webpack_require__(6);
	
	console.log(eiti, '--', window, '--', exports)
	
	// Glossary
	// require("./vendor/lodash.min.js");
	// require("./vendor/list.min.js");
	// require("./components/glossary.js");
	
	
	// <script src="{{ site.baseurl }}/js/eiti.js"></script>
	//     <script>
	//       eiti.data.path = '{{ site.baseurl }}/data/';
	//       eiti.commodities = ({{ site.data.commodities|jsonify }});
	//       eiti.resource = ({{ site.data.resource|jsonify }});
	//     </script>
	
	
	// currently eiti and List are experiencing issues with CommonJS/RequireJS module requirement:
	// http://webpack.github.io/docs/commonjs.html


/***/ },
/* 1 */,
/* 2 */
/***/ function(module, exports) {

	/*! (C) WebReflection Mit Style License */
	(function(e,t,n,r){"use strict";function rt(e,t){for(var n=0,r=e.length;n<r;n++)vt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(vt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute("is"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is="'+t+'"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!=="style"&e.prevValue!==e.newValue&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(n--,F.splice(t--,1),vt(e,o))}function dt(e){throw new Error("A "+e+" type is already registered")}function vt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+"Callback"])&&n.call(e))}if(r in t)return;var i="__"+r+(Math.random()*1e5>>0),s="attached",o="detached",u="extends",a="ADDITION",f="MODIFICATION",l="REMOVAL",c="DOMAttrModified",h="DOMContentLoaded",p="DOMSubtreeModified",d="<",v="=",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=["ANNOTATION-XML","COLOR-PROFILE","FONT-FACE","FONT-FACE-SRC","FONT-FACE-URI","FONT-FACE-FORMAT","FONT-FACE-NAME","MISSING-GLYPH"],y=[],b=[],w="",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function mt(e){return e?(mt.prototype=e,new mt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,"addEventListener"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:"class",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,"propertychange",s)),t.call(this,e,o,u)},C(H,"addEventListener",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!=="setAttribute"&&(r[n]=t.value);return r})),t[r]=function(n,r){c=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o,u=0,a=r.length;u<a;u++)i=r[u],i.type==="childList"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!=="style"&&(o=s.getAttribute(i.attributeName),o!==i.oldValue&&s.attributeChangedCallback(i.attributeName,i.oldValue,o)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener("DOMNodeInserted",ft(s)),t.addEventListener("DOMNodeRemoved",ft(o))),t.addEventListener(h,lt),t.addEventListener("readystatechange",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=""+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute("is",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t}),-2<S.call(y,v+c)+S.call(y,d+c)&&dt(n);if(!m.test(c)||-1<S.call(g,c))throw new Error("The type "+n+" is invalid");var i=function(){return f?t.createElement(l,c):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():c,c,p;return f&&-1<S.call(y,d+l)&&dt(l),p=y.push((f?v:d)+c)-1,w=w.concat(w.length?",":"",f?l+'[is="'+n.toLowerCase()+'"]':l),i.prototype=b[p]=T.call(a,"prototype")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,"registerElement");

/***/ },
/* 3 */
/***/ function(module, exports) {

	// globals d3, topojson, eiti
	(function(exports) {
	  'use strict';
	
	  exports.EITIMap = document.registerElement('eiti-map', {
	    // 'extends': 'svg',
	    prototype: Object.create(
	      HTMLElement.prototype,
	      {
	
	        createdCallback: {value: function() {
	        }},
	
	        attachedCallback: {value: function() {
	          this.load();
	        }},
	
	        attributeChangedCallback: {value: function(attr, old, value) {
	          switch (attr) {
	            case 'width':
	            case 'height':
	              updateSize(this.querySelector('svg'));
	              break;
	
	            case 'zoom-to':
	              this.zoomTo(value);
	              break;
	          }
	        }},
	
	        detachedCallback: {value: function() {
	        }},
	
	        load: {value: function() {
	          this.loaded = false;
	
	          var map = this.querySelector('svg');
	          var layers = getDataLayers(this);
	
	          var q = queue();
	          var len = 0;
	          layers.each(function() {
	            if (this.getAttribute('data-load') === 'false') {
	              console.warn('<eiti-map> not loading layer:', this);
	              return;
	            }
	            var layer = this;
	            q.defer(function(done) {
	              loadLayer(layer, done);
	            });
	            len++;
	          });
	
	          if (len) {
	            var selection = d3.select(this)
	              .classed('js-loading', true);
	
	            var self = this;
	            q.await(function(error) {
	              selection.classed('js-loading', false);
	              if (error) {
	                selection.classed('js-error', true);
	                return self.dispatchEvent(new CustomEvent('error', error));
	              }
	              render(map);
	
	              if (self.hasAttribute('zoom-to')) {
	                self.zoomTo(self.getAttribute('zoom-to'));
	              } else {
	                updateBBox(map);
	              }
	
	              selection.classed('js-loaded', true);
	
	              self.dispatchEvent(new CustomEvent('load'));
	              self.loaded = true;
	            });
	
	          } else {
	            console.warn('no data layers in:', this);
	          }
	        }},
	
	        zoomTo: {value: function(featureId, duration) {
	          var map = this.querySelector('svg');
	          var selection = d3.select(map);
	
	          var feature;
	          selection
	            .selectAll('path')
	            .classed('zoomed', function(d) {
	              if (!feature && d.id && d.id == featureId) {
	                feature = d;
	                return true;
	              }
	              return false;
	            });
	
	          var viewBox;
	          if (feature) {
	            var path = getSVGPath(map);
	            var bbox = path.bounds(feature);
	            viewBox = bboxToViewBox(bbox);
	          } else {
	            console.warn('zoom to:', featureId, 'no such feature');
	            viewBox = getViewBox(map);
	          }
	
	          if (!isNaN(duration) && duration > 0) {
	            selection = selection.transition()
	              .duration(duration);
	          }
	          selection.attr('viewBox', viewBox);
	        }}
	
	      })
	    });
	
	  function render(map) {
	    var path = getSVGPath(map);
	    var layers = getDataLayers(map);
	    layers.call(renderLayer(path));
	    map.dispatchEvent(new CustomEvent('render'));
	  }
	
	  function getProjection(map) {
	    if (map.__projection) {
	      return map.__projection;
	    }
	    var proj = map.getAttribute('projection') ||
	      map.parentNode.getAttribute('projection') || 'albersUsa';
	    if (!d3.geo[proj]) {
	      throw new Error('invalid projection: "' + proj + '"');
	    }
	    proj = d3.geo[proj]();
	    // TODO: additional projection parameters?
	    return map.__projection = proj;
	  }
	
	  function getSVGPath(map) {
	    var proj = getProjection(map);
	
	    var path = d3.geo.path()
	      .projection(proj);
	
	    if (map.hasAttribute('simplify')) {
	      var area = +map.getAttribute('simplify');
	      var skipped = 0;
	      var simplify = d3.geo.transform({
	        point: function(x, y, z) {
	          if (z >= area) {
	            var p = proj([x, y]);
	            this.stream.point(p[0], p[1]);
	          } else {
	            skipped++;
	          }
	        },
	        polygon: function(d) {
	          skipped = 0;
	          this.stream.polygon(d);
	          if (skipped) {
	            console.log('skipped %d points in polygon:', skipped, polygon);
	          }
	        }
	      });
	      return path.projection(simplify);
	    }
	
	    return path;
	  }
	
	  function renderLayer(path) {
	    return function(selection) {
	      selection.each(function(d) {
	        var layer = d3.select(this)
	          .attr('data-type', d.type);
	
	        var filter = this.getAttribute('data-filter');
	        var features = [];
	        var key;
	        switch (d.type) {
	
	          case 'Topology':
	            d = topojson.presimplify(d);
	            features = getTopologyFeatures(this, d, filter);
	            layer.classed('topology', true);
	            if (!d.bbox) {
	              d.bbox = getBBox(features.map(path.bounds));
	            }
	            break;
	
	          case 'FeatureCollection':
	            features = d.features;
	            layer.classed('collection', true);
	            // FIXME: presimplify?
	            break;
	
	          default:
	            features = [d];
	            layer.classed('feature', true);
	            // FIXME: presimplify?
	            break;
	        }
	
	        if (filter) {
	          // console.log('filter %d features with expression:', features.length, '"' + filter + '"');
	          filter = evaluator(filter);
	          // only apply the filter to non-mesh features
	          features = features.filter(function(d) {
	            return d.mesh || filter(d);
	          });
	          // console.log('filtered %d features', features.length);
	        }
	
	        var feature;
	        if (this.hasAttribute('data-href')) {
	
	          var link = layer.selectAll('a')
	            .data(features, function(d, i) {
	              return d.id || i;
	            });
	
	          link.exit().remove();
	          link.enter().append('a')
	            .append('path')
	              .append('title');
	
	          var href = evaluator(this.getAttribute('data-href'));
	          link
	            .filter(function(d) { return !d.mesh; })
	            .attr('xlink:href', href);
	
	          feature = link.select('path');
	
	        } else {
	
	          feature = layer.selectAll('path')
	            .data(features);
	
	          feature.exit().remove();
	          feature.enter().append('path')
	            .append('title');
	
	        }
	
	        feature
	          .attr('d', path)
	          .attr('id', evaluator(this.getAttribute('data-id') || 'id'))
	          .attr('class', function(d) {
	            var klass = [];
	            if (d.mesh) klass.push('mesh');
	            else klass.push('feature');
	            return klass.join(' ');
	          });
	
	        if (this.hasAttribute('data-title')) {
	          var title = evaluator(this.getAttribute('data-title'));
	          feature.select('title')
	            .filter(function(d) { return !d.mesh; })
	            // .each(function(d) { console.log('title:', d); })
	            .text(title);
	        }
	
	        this.dispatchEvent(new CustomEvent('renderLayer'));
	      });
	    };
	  }
	
	  function updateSize(map) {
	    var width = map.getAttribute('width') || 800;
	    var height = map.getAttribute('height') || 600;
	    var viewBox = [0, 0, width, height];
	    d3.select(map)
	      .attr('viewBox', viewBox.join(' '));
	  }
	
	  function updateBBox(map) {
	    if (!map.hasAttribute('viewBox')) {
	      var viewBox = getViewBox(map);
	      d3.select(map)
	        .attr('viewBox', viewBox);
	    }
	  }
	
	  function getViewBox(map) {
	    var bbox = map.getAttribute('bounds');
	    var path = getSVGPath(map);
	    var proj = getProjection(map);
	
	    var bounds = function(d) {
	      if (d.type === 'Topology') {
	        return d.bbox;
	      } else {
	        return path.bounds(d);
	      }
	    };
	
	    if (bbox) {
	      // "xmin ymin xmax ymax"
	      var parts = bbox.split(' ').map(Number);
	      bbox = [
	        proj([parts[0], parts[1]]),
	        proj([parts[2], parts[3]])
	      ];
	    } else {
	      var layers = getDataLayers(map);
	
	      layers.filter('[bbox="true"]')
	        .each(function(d) {
	          bbox = bounds(d);
	        });
	
	      if (!bbox) {
	        var bboxes = layers.data()
	          .filter(function(d) { return d; })
	          .map(function(d) {
	            return bounds(d);
	          });
	        bbox = getBBox(bboxes);
	      }
	      // console.log('bbox:', bbox);
	    }
	
	    return bbox ? bboxToViewBox(bbox) : null;
	  }
	
	
	  function bboxToViewBox(bbox, padding) {
	    padding = isNaN(padding) ? 10 : padding;
	    return [
	      bbox[0][0] - padding,
	      bbox[0][1] - padding,
	      bbox[1][0] - bbox[0][0] + padding * 2,
	      bbox[1][1] - bbox[0][1] + padding * 2
	    ].join(' ');
	  }
	
	
	  function getDataLayers(map) {
	    return d3.select(map)
	      .selectAll('[data-url], [data-feature]');
	  }
	
	  function loadLayer(layer, done) {
	    var selection = d3.select(layer);
	
	    if (layer.hasAttribute('data-feature')) {
	      var feature = layer.getAttribute('data-feature');
	      try {
	        feature = JSON.parse(feature);
	      } catch (error) {
	        throw new Error('Unable to parse data-feature="' + feature + '"');
	      }
	      selection
	        .datum(feature)
	        .classed('js-loaded', true);
	      return done(null, selection);
	    }
	
	    var parent = layer.parentNode;
	    while (!is(parent, 'eiti-map')) {
	      parent = parent.parentNode;
	    }
	    var path = parent.getAttribute('data-path') || '';
	    var url = path + layer.getAttribute('data-url');
	    // console.log('url:', layer, path, '->', url);
	    if (!url) return done('no URL');
	
	    selection.classed('js-loading', true);
	    eiti.load(url, function(error, data) {
	      selection.classed('js-loading', false);
	      if (error) {
	        selection.classed('js-error', true);
	        return done(error);
	      }
	      selection
	        .classed('js-loaded', true)
	        .datum(data);
	      done(null, selection);
	    });
	  }
	
	  function parseBBox(value) {
	    return value
	      ? value.trim().split(/\s+/).map(Number)
	      : null;
	  }
	
	  function getBBox(bboxes) {
	    var xmin = Infinity,
	        ymin = Infinity,
	        xmax = -Infinity,
	        ymax = -Infinity,
	        len = bboxes.length;
	    for (var i = 0; i < len; i++) {
	      var b = bboxes[i];
	      if (!b) continue;
	      if (b[0][0] < xmin) xmin = b[0][0];
	      if (b[0][1] < ymin) ymin = b[0][1];
	      if (b[1][0] > xmax) xmax = b[1][0];
	      if (b[1][1] > ymax) ymax = b[1][1];
	    }
	    return [[xmin, ymin], [xmax, ymax]];
	  }
	
	  function getTopologyFeatures(node, d, filter) {
	    var key;
	    var mesh = node.getAttribute('data-mesh');
	    var features;
	
	    if (node.hasAttribute('data-object')) {
	      key = node.getAttribute('data-object');
	
	      var obj = d.objects[key];
	      if (!obj) {
	        throw new Error(
	          'invalid object: "' +
	          key + '" in: ["' +
	          Object.keys(d.objects).join('", "') +
	          '"]'
	        );
	      }
	
	      features = getFeatures(d, obj);
	
	      if (mesh) {
	        features.push(d.objects[mesh]
	          ? getMesh(d, d.objects[mesh], filter)
	          : getMesh(d, obj, filter));
	      }
	    } else {
	      features = [];
	      var keys = Object.keys(d.objects);
	      var meshIds = (mesh || '').split(',');
	      for (key in d.objects) {
	        features = features.concat(topojson.feature(d, d.objects[key]).features);
	        if (mesh === 'true' || meshIds.indexOf(key) > -1) {
	          features.push(getMesh(d, d.objects[key], filter));
	        }
	      }
	    }
	    return features;
	  }
	
	  function getMesh(topology, object, filter) {
	    if (!object) {
	      console.warn('no mesh!');
	      return {
	        type: 'Geometry',
	        geom: {
	          type: 'Point',
	          coordinates: [0, 0]
	        },
	        properties: {}
	      };
	    }
	    if (filter) {
	      filter = evaluator(filter);
	      // console.log('filtering %d geometries', object.geometries.length);
	      object = {
	        type: 'GeometryCollection',
	        geometries: object.geometries
	          .filter(filter)
	      };
	      // console.log('filtered %d geometries', object.geometries.length);
	    }
	    var mesh = topojson.mesh(topology, object);
	    mesh.mesh = true;
	    return mesh;
	  }
	
	  function extend(parent, proto) {
	    var constructor = document.createElement(parent).constructor;
	    for (var key in proto) {
	      if (typeof proto[key] === 'function') {
	        proto[key] = {value: proto[key]};
	      }
	    }
	    return Object.create(constructor.prototype, proto);
	  }
	
	  function assign(obj, keys) {
	    for (var key in keys) {
	      obj[key] = keys[key];
	    }
	    return obj;
	  }
	
	  function is(node, name) {
	    return node.nodeName.toLowerCase() === name
	        || node.getAttribute('is') === name;
	  }
	
	  function evaluator(expression) {
	    return new Function(
	      'd', [
	        'with (d) { try { ',
	          'return (' + expression + '); ',
	        '} catch (error) { ',
	          'return null; ',
	        '} }'
	      ].join(''));
	  }
	
	  function getFeatures(topology, obj) {
	    return topojson.feature(topology, obj).features;
	  }
	
	})(this);


/***/ },
/* 4 */
/***/ function(module, exports) {

	// globals d3
	(function(exports) {
	  console.log('eiti-sllider',exports)
	
	  exports.EITISlider = registerElement('eiti-slider', {
	    createdCallback: function() {
	      // console.log('eiti-slider created');
	      this.setAttribute('unresolved', '');
	      this.min = getAttr.call(this, 'min', 0);
	      this.max = getAttr.call(this, 'max', 100);
	      this.value = getAttr.call(this, 'value', 0);
	      this.snap = this.hasAttribute('snap');
	    },
	
	    attachedCallback: function() {
	      // console.log('eiti-slider attached');
	
	      this.removeAttribute('unresolved');
	      this.__handle = this.querySelector('.handle') || createHandle.call(this);
	      this.update();
	
	      this.addEventListener('click', events.click);
	      this.addEventListener('mousedown', events.engage);
	      this.addEventListener('touchstart', events.engage);
	      this.addEventListener('focus', events.focus, true);
	    },
	
	    detachedCallback: function() {
	      // console.log('eiti-slider detached');
	      this.removeEventListener('click', events.click);
	      this.removeEventListener('mousedown', events.enagage);
	      this.removeEventListener('touchstart', events.enagage);
	      this.removeEventListener('focus', events.focus, true);
	    },
	
	    attributeChangedCallback: function(attr, prev, value) {
	      switch (attr) {
	        case 'min':
	        case 'max':
	        case 'value':
	        case 'snap':
	          // console.log('eiti-slider attr: ', attr, ' = ', value);
	          this[attr] = value;
	          this.update();
	          break;
	      }
	    },
	
	    update: function() {
	      if (this.hasAttribute('unresolved')) return;
	
	      var min = this.min;
	      var max = this.max;
	      var value = this.value;
	
	      var x = function(value) {
	        return 100 * (value - min) / (max - min);
	      };
	
	      var handle = this.__handle;
	      var left = x(value);
	      // console.log('left: ', value, ' -> ', left);
	      handle.style.setProperty('left', left.toFixed(2) + '%');
	
	      var text = handle.querySelector('.value');
	      if (text) {
	        text.textContent = String(value);
	        var textWidth = text.getBoundingClientRect().width;
	        var marginLeft = (-textWidth / 2);
	        text.style.setProperty('margin-left', marginLeft + 'px');
	      }
	
	      var ticks = d3.select(this)
	        .selectAll('.tick')
	        .data(d3.range(this.min, this.max + 1));
	
	      ticks.exit().remove();
	      ticks.enter().append('div')
	        .attr('class', 'tick')
	        .append('span')
	          .attr('class', 'label');
	
	      ticks
	        .style('left', function(d) {
	          return x(d).toFixed(2) + '%';
	        })
	        .select('.label')
	          .text(function(d) { return d; });
	
	      try {
	        var event = new CustomEvent('change', {
	          value: value
	        });
	        this.dispatchEvent(event);
	      } catch (err) {
	        console.warn('unable to fire "change" event: ', err);
	      }
	    },
	
	    // clamp to min and max, round if snap === true
	    value: property('value', function(v) {
	      v = clamp(+v, this.min, this.max);
	      if (this.snap) v = Math.round(v);
	      return v;
	    }),
	
	    // parse min and max as numbers
	    min: property('min', Number),
	    max: property('max', Number),
	
	    name: {
	      get: function() {
	        return this.getAttribute('name');
	      },
	      set: function(name) {
	        this.setAttribute('name', name);
	      }
	    },
	
	    // parse snap as a boolean
	    snap: property('snap', Boolean)
	  });
	
	  // so that event listeners
	  var events = {
	    click: function(e) {
	      // ignore right-clicks
	      if (e.button === 2) return false;
	
	      var rect = this.getBoundingClientRect();
	      var width = rect.width;
	      var x = e.clientX - rect.left;
	      // console.log('click: ', e.clientX, ', ', rect.left, ' -> ', x);
	      var value = this.min + (x / width) * (this.max - this.min);
	      if (this.snap) value = Math.round(value);
	      // console.log('value: ', value);
	      this.value = value;
	      this.update();
	    },
	
	    engage: function(e) {
	      // ignore right-clicks
	      if (e.button === 2) {
	        e.preventDefault();
	        return false;
	      }
	
	      this.__dragging = true;
	      this.classList.add('__dragging');
	
	      window.addEventListener('mousemove', getListener('move', this));
	      window.addEventListener('touchmove', getListener('move', this));
	      window.addEventListener('mouseup', getListener('release', this));
	      window.addEventListener('touchend', getListener('release', this));
	    },
	
	    move: function(e) {
	      events.click.call(this, e);
	      e.preventDefault();
	      return false;
	    },
	
	    release: function(e) {
	      this.__dragging = false;
	      this.classList.remove('__dragging');
	      window.removeEventListener('mousemove', getListener('move', this));
	      window.removeEventListener('touchmove', getListener('move', this));
	      window.removeEventListener('mouseup', getListener('release', this));
	      window.removeEventListener('touchend', getListener('release', this));
	      e.preventDefault();
	      return false;
	    },
	
	    keypress: function(e) {
	      // console.log('keypress:', e);
	      switch (e.keyCode) {
	        case 37: // left
	          this.value--;
	          break;
	        case 39: // right
	          this.value++;
	          break;
	      }
	    },
	
	    focus: function() {
	      window.addEventListener('keyup', getListener('keypress', this));
	      this.addEventListener('blur', events.blur);
	    },
	
	    blur: function() {
	      window.removeEventListener('keyup', getListener('keypress', this));
	      this.removeEventListener('blur', events.blur);
	    }
	
	  };
	
	  function getListener(type, obj) {
	    var key = '__' + type;
	    return obj[key] || (obj[key] = events[type].bind(obj));
	  }
	
	  function registerElement(name, proto, parent) {
	    if (!parent) parent = HTMLElement;
	    for (var key in proto) {
	      if (typeof proto[key] === 'function') {
	        proto[key] = {value: proto[key]};
	        if (key.indexOf('__') === 0) {
	          proto[key].enumerable = false;
	        }
	      }
	    }
	    return document.registerElement(name, {
	      prototype: Object.create(
	        parent.prototype,
	        proto
	      )
	    });
	  }
	
	  function getAttr(name, fallback) {
	    return this.hasAttribute(name)
	      ? this.getAttribute(name)
	      : fallback;
	  }
	
	  function property(name, parse) {
	    var key = '__' + name;
	    return {
	      get: function() {
	        return this[key];
	      },
	      set: function(value) {
	        if (parse) value = parse.call(this, value, name);
	        if (value !== this[key]) {
	          this[key] = value;
	          this.update();
	        }
	      }
	    };
	  }
	
	  function createHandle() {
	    var div = document.createElement('div');
	    div.className = 'handle';
	    return this.appendChild(div);
	  }
	
	  function clamp(x, min, max) {
	    if (x < min) return min;
	    else if (x > max) return max;
	    return x;
	  }
	  console.log('post-slide',exports)
	})(this);


/***/ },
/* 5 */
/***/ function(module, exports) {

	(function(exports) {
	
	  var symbols = {
	    collapsed: '__collapsedText',
	    expanded: '__expandedText'
	  };
	
	  var innerMarkup = {
	    bars: '<span class="u-visually-hidden"><icon class="icon-bars"></icon></span>',
	    x: '<span class="u-visually-hidden"><icon class="icon-close-x"></icon></span>'
	  };
	
	  var EXPANDED = 'aria-expanded';
	  var CONTROLS = 'aria-controls';
	  var HIDDEN = 'aria-hidden';
	
	  exports.EITIToggle = document.registerElement('eiti-toggle', {
	    'extends': 'button',
	    prototype: Object.create(HTMLButtonElement.prototype, {
	
	      attachedCallback: {value: function() {
	        this.addEventListener('click', toggle);
	        update.call(this);
	      }},
	
	      detachedCallback: {value: function() {
	        this.removeEventListener('click', toggle);
	      }},
	
	      attributeChangedCallback: {value: function(attr, prev, value) {
	        switch (attr) {
	          case EXPANDED:
	            update.call(this);
	            break;
	        }
	      }},
	
	      controlAttribute: {
	        get: function() {
	          return this[attrControl] || HIDDEN;
	        },
	        set: function(attr) {
	          this[attrControl] = attr;
	        }
	      },
	
	      collapsedText: {
	        get: function() {
	          return this[symbols.collapsed]
	            || this.getAttribute('data-collapsed-text')
	            || this.textContent;
	        },
	        set: function(text) {
	          this[symbols.collapsed] = text;
	          update.call(this);
	        }
	      },
	
	      expandedText: {
	        get: function() {
	          return this[symbols.expanded]
	            || this.getAttribute('data-expanded-text')
	            || this.textContent;
	        },
	        set: function(text) {
	          this[symbols.expanded] = text;
	          update.call(this);
	        }
	      },
	
	      expanded: {
	        get: function() {
	          return this.getAttribute(EXPANDED) === 'true';
	        },
	        set: function(expanded) {
	
	          // coerce strings to booleans
	          if (expanded === 'true') {
	            expanded = true;
	          } else if (expanded === 'false') {
	            expanded = false;
	          } else {
	            expanded = !!expanded;
	          }
	
	          var toggleId = this.getAttribute(CONTROLS);
	          var togglers = document.querySelectorAll('[data-toggler=' + toggleId + ']');
	
	          if (togglers.length) {
	
	            // togglers is a NodeList, not an Array
	            if (togglers) {
	              Array.prototype.forEach.call(togglers, function(toggle) {
	                toggle.setAttribute(EXPANDED, expanded);
	              });
	            }
	          } else {
	            this.setAttribute(EXPANDED, expanded);
	          }
	
	        }
	      }
	    })
	  });
	
	  function toggle() {
	    this.expanded = !this.expanded;
	  }
	
	  function update() {
	    this.textContent = this.expanded
	      ? this.expandedText
	      : this.collapsedText;
	
	    var attrInnerMarkup = this.getAttribute('data-inner-markup');
	    if (attrInnerMarkup) {
	      this.innerHTML = innerMarkup[attrInnerMarkup];
	    }
	
	    var id = this.getAttribute(CONTROLS);
	
	
	    var target = document.getElementById(id);
	    var expanded = this.expanded;
	
	    if (target) {
	      expanded = !target.getAttribute(HIDDEN);
	      target.setAttribute(HIDDEN, !this.expanded);
	    }
	
	
	  }
	
	})(this);


/***/ },
/* 6 */
/***/ function(module, exports) {

	$( document ).ready(function() {
	  // Beckley Search Form
	  //
	  // As a work of the United States Government, this package is in the public domain within the United States. Additionally, we waive copyright and related rights in the work worldwide through the CC0 1.0 Universal public domain dedication.
	  //
	  // By Sean Herron <sean@herron.io>
	  //
	  function GetURLParameter(sParam) {
	    var sPageURL = window.location.search.substring(1);
	    var sURLVariables = sPageURL.split('&');
	    for (var i = 0; i < sURLVariables.length; i++) {
	      var sParameterName = sURLVariables[i].split('=');
	      if (sParameterName[0] == sParam) {
	        return sParameterName[1];
	      }
	    }
	  }
	
	  var query = GetURLParameter('q') || '';
	  $(".search-string").append(query.replace(/%20/g,' '));
	  $("#site-search-text").attr('value',query.replace(/%20/g,' '));
	  if(query) {
	    $("input#q").val(query);
	    $("#search-result-list").append('<div class="loading"><span class="glyphicon glyphicon-refresh"></span> Loading</div>');
	    $.ajax({
	      url: "https://api.data.gov/beckley-federalist/v0/resources/eiti/?q=" + query + "&size=50&from=0&api_key=LXJh2PKSC6zxY0YNuBRYgIj2JxSPcDwSPCZuHBG1",
	      cache: false,
	      dataType: "json"
	    })
	      .done(function(json) {
	        $(".loading").remove();
	        $("#search-results-count").append( json.hits.total + ' search results');
	        if (json.hits.total == 0){
	          $("#search-no-results").show();
	        }
	        else{
	          $("#search-no-results").remove();
	        }
	
	        $.each(json.hits.hits, function(i, hit){
	
	        var result_description = hit._source.description;
	
	          var tags = '';
	          if(hit._source.tag) {
	
	            $.each(hit._source.tag, function(i, tag) {
	              tags += '<span class="search-result-list-tag">&nbsp;<a href="../search-results/?q='
	              + tag + '" title="Search for '
	              + tag +'">'
	              + tag + '</a>&nbsp;/</span>';
	            });
	          }
	
	          var content_type = "";
	          if(hit._source.content_type == "text/html") {
	            content_type = '<span class="glyphicon glyphicon-link"></span> Website';
	          }
	          else if(hit._source.content_type == "application/pdf") {
	            content_type = '<span class="glyphicon glyphicon-file"></span> PDF';
	          }
	          else {
	            content_type = '<span class="glyphicon glyphicon-file"></span> ' + hit._source.content_type + '';
	          }
	          $("#search-results-container").append('<article class="search-result-list"><h1><a href="'
	            + hit._source.url
	            + '" target="_blank">'
	            + hit._source.title
	            + '</a></h1>'
	            +'<p>'
	            + result_description
	            + '</p>'
	            +'<p>Tagged&nbsp;/'
	            + tags
	            +'</p>'
	            +'</article>');
	        });
	      });
	  }
	  else {
	    $("#search-no-results").show();
	    $(".loading").remove();
	    $("#search-results-count").append( 0 + ' search results');
	
	  }
	});


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	(function(exports) {
	  'use strict';
	
	  /*
	   * @namespace eiti
	   */
	
	  var eiti = window.eiti = exports.eiti = {};
	
	  /**
	   * Load a URL by inferring its data type based on the extension (.csv, .tsv,
	   * or .json) and cache responses for repeated calls.
	   *
	   * @param String      url       the URL to load
	   * @param Function    callback  the error-first (`(error, data)`) callback
	   *                              function
	   * @param {Boolean?}  fresh     if truthy, don't load this file from the cache
	   *
	   * @return Object     a d3.xhr response (or -like) object with an
	   *                    `abort()` method.
	   */
	  eiti.load = (function() {
	    var cache = d3.map();
	
	    var loading = d3.map();
	
	    var loaders = {};
	    ['csv', 'tsv', 'json'].forEach(function(type) {
	      loaders[type] = d3[type];
	    });
	
	    var load = function(url, done, fresh) {
	      var req;
	      if (loading.has(url)) {
	        req = loading.get(url);
	        req.callbacks.push(done);
	        return req;
	      }
	
	      var ext = url.split('.').pop().split('?').shift();
	      var loader = loaders[ext];
	      var cached = cache.get(url);
	      if (cached && !fresh) {
	        requestAnimationFrame(function() {
	          // console.log('[defer] load cached:', url);
	          done(null, cached);
	        });
	        return;
	      }
	
	      req = loader.call(d3, url, function(error, data) {
	        // console.log('loaded:', url);
	        loading.remove(url);
	        if (!error) {
	          cache.set(url, data);
	        }
	        process(req.callbacks, error, data);
	      });
	
	      // override the abort() method to remove this
	      // request from the loading map
	      var abort = req.abort;
	      req.abort = function() {
	        // console.info('[eiti.load] aborted:', url);
	        loading.remove(url);
	        abort();
	      };
	
	      req.callbacks = [done];
	      loading.set(url, req);
	      return req;
	    };
	
	    var process = function(callbacks, error, data) {
	      if (callbacks.length === 1) {
	        return callbacks[0](error, data);
	      }
	      var next = function() {
	        var cb = callbacks.shift();
	        cb(error, data);
	        if (callbacks.length) {
	          window.requestAnimationFrame(next);
	        }
	      };
	      return next();
	    };
	
	    load.clearCache = function() {
	      var keys = cache.keys();
	      keys.forEach(cache.remove);
	      return keys;
	    };
	
	    return load;
	  })();
	
	  eiti.loadAll = function(sources, done) {
	    var q = queue();
	    var result = {};
	    Object.keys(sources).forEach(function(key) {
	      q.defer(function(next) {
	        eiti.load(sources[key], function(error, data) {
	          if (error) {
	            return next(error);
	          }
	          next(null, result[key] = data);
	        });
	      });
	    });
	    return q.await(function(error) {
	      return done(error, result);
	    });
	  };
	
	  /*
	   * data classes and functions
	   */
	  eiti.data = {};
	
	  /**
	   * Nest data into an object structure:
	   * @name eiti.data.nest
	   *
	   * @example
	   * var data = [{x: 1, y: 2}, {x: 2, y: 2}];
	   * var nested = eiti.data.nest(data, ['x', 'y']);
	   * assert.deepEqual(nested, {
	   *   1: {
	   *     2: [
	   *       {x: 1, y: 2}
	   *     ]
	   *   },
	   *   2: {
	   *     2: [
	   *       {x: 2, y: 2}
	   *     ]
	   *   }
	   * });
	   *
	   * @param {Array} rows a dimensional tabular data set
	   * @param {Array} keys a list of key functions or property names
	   * @param {Function=} rollup an optional value rollup function
	   */
	  eiti.data.nest = function(rows, keys, rollup) {
	    var nest = d3.nest();
	    keys.forEach(function(k) {
	      nest.key(getter(k));
	    });
	    if (rollup) {
	      nest.rollup(rollup);
	    }
	    return nest.map(rows);
	  };
	
	  /**
	   * Walk a nested object structure and call a function on each
	   * "leaf" node (that is not an object).
	   * @name eiti.data.walk
	   *
	   * @example
	   * var value = [];
	   * eiti.data.walk({foo: {bar: 'baz'}}, function(d, i) {
	   *   values.push(d);
	   * });
	   * assert.deepEqual(values, ['baz']);
	   *
	   * @param {Array|Object} data the array or object to iterate over
	   * @param {Function} callback the function to call on each leaf node
	   * @return void
	   */
	  eiti.data.walk = function(struct, each) {
	    walk(struct);
	
	    function walk(d, i) {
	      if (Array.isArray(d)) {
	        return d.forEach(function(v, i) {
	          walk.call(d, v, i);
	        });
	      } else if (typeof d === 'object') {
	        return d3.keys(d).forEach(function(key) {
	          walk.call(d, d[key], key);
	        });
	      } else {
	        each.call(this, d, i);
	      }
	    }
	  };
	
	  /**
	   * Create a key getter function a la Python's
	   * itertools.itemgetter().
	   * @name eiti.data.getter
	   *
	   * @example
	   * var title = eiti.data.getter('title');
	   * var titles = data.map(title);
	   *
	   * @param {String|Number|Function} key
	   * @return {Function}
	   */
	  eiti.data.getter = getter;
	
	  // UI bits
	  eiti.ui = {};
	
	  /**
	   * Create an augmented [d3-tip](https://github.com/Caged/d3-tip)
	   * instance with "show" and "hide" event dispatching capabilities.
	   * EITI tips also have a `.target()` accessor which allows you to
	   * override the element that's used to calculate tooltip
	   * positioning.
	   * @name eiti.ui.tip
	   *
	   * @example
	   * var tip = eiti.ui.tip()
	   *   .on('show', function() {
	   *     console.log('tip show:', this);
	   *   })
	   *   .target(function() {
	   *     return this.querySelector('circle');
	   *   });
	   */
	  eiti.ui.tip = function() {
	    var tip = d3.tip();
	    var show = tip.show;
	    var hide = tip.hide;
	    var dispatch = d3.dispatch('show', 'hide');
	
	    var target = null;
	
	    var showClass = classify('show', 'hide');
	    var hideClass = classify('hide', 'show');
	
	    /*
	     * Override the target of the tooltip for positioning purposes.
	     * @example
	     * tip.target(function() {
	     *   return this.querySelector('circle');
	     * });
	     */
	    tip.target = function(_) {
	      if (!arguments.length) {
	        return target;
	      }
	      target = d3.functor(_);
	      return tip;
	    };
	
	    tip.show = function() {
	      var args = arguments;
	      dispatch.show.apply(this, arguments);
	      if (target) {
	        var t = target ? target.apply(this, arguments) : null;
	        if (t) {
	          args = [].slice.call(args).concat([t]);
	        }
	      }
	      tip.attr('class', showClass);
	      return show.apply(this, args);
	    };
	
	    tip.hide = function() {
	      dispatch.hide.apply(this, arguments);
	      tip.attr('class', hideClass);
	      return hide.apply(this, arguments);
	    };
	
	    return d3.rebind(tip, dispatch, 'on');
	  };
	
	  eiti.ui.expando = function(selection) {
	    selection.datum(function(d) {
	      var text = this.textContent;
	      return d || {
	        'true': this.getAttribute('data-expanded-text') || text,
	        'false': this.getAttribute('data-collapsed-text') || text
	      };
	    })
	    .on('click.expando', eiti.ui.expando.toggle);
	  };
	
	  eiti.ui.expando.toggle = function toggle(d) {
	    var id = this.getAttribute('aria-controls');
	    var hidden = 'aria-hidden';
	    var target = d3.select('#' + id);
	    var expanded = target.attr(hidden) !== 'false';
	    target.attr(hidden, !expanded);
	    if (d) {
	      this.textContent = d[expanded];
	    }
	    this.setAttribute('aria-expanded', expanded);
	  };
	
	  eiti.util = {};
	
	  /**
	   * Extend objects with additional properties, a la `$.extend()`.
	   * @name eiti.util.extend
	   *
	   * @param {Object} base   the base object onto which all other
	   *                        properties will be added
	   * @param {Object=} other one or more additional objects with
	   *                        properties to be copied
	   * @return {Object} the `base` object with added properties
	   */
	  eiti.util.extend = function(obj) {
	    [].slice.call(arguments, 1).forEach(function(o) {
	      for (var key in o) { /* jshint -W089 */
	        obj[key] = o[key];
	      }
	    });
	    return obj;
	  };
	
	  /**
	   * Force a reset of location.hash so that the browser (hopefully)
	   * scrolls to the element with the fragment identifier and toggles
	   * the :target pseudo-class.
	   * @name eiti.util.jiggleHash
	   *
	   * @return {Boolean}
	   */
	  eiti.util.jiggleHash = function() {
	    var hash = location.hash;
	    if (hash) {
	      location.hash = '';
	      location.hash = hash;
	      return true;
	    }
	    return false;
	  };
	
	  /**
	   * d3 helper for bringing an element to the front among its
	   * siblings. Use it with an event listener, e.g.:
	   * @name eiti.util.bringToFront
	   *
	   * @example
	   * d3.selectAll('svg path')
	   *   .on('mouseover', eiti.util.bringToFront);
	   */
	  eiti.util.bringToFront = function() {
	    this._nextSibling = this.nextSibling;
	    this.parentNode.appendChild(this);
	  };
	
	  /**
	   * The compliment to {@link bringToFront}, returns an
	   * element to its previous position among its siblings.
	   * @name eiti.util.sendToBack
	   *
	   * @example
	   * d3.selectAll('svg path')
	   *   .on('mouseover', eiti.util.bringToFront)
	   *   .on('mouseout', eiti.util.sendToBack);
	   */
	  eiti.util.sendToBack = function() {
	    this.parentNode.insertBefore(this, this._nextSibling);
	    delete this._nextSibling;
	  };
	
	  // TODO: document
	  eiti.util.classify = classify;
	
	
	  /**
	   * Coerce a d3-style format string or function into a number
	   * format function.
	   */
	  eiti.format = function(format) {
	    return (typeof format === 'function')
	      ? format
	      : d3.format(format);
	  };
	
	  /**
	   * Create a composite format that wraps a d3 format (or any other
	   * formatting function) with a transform function.
	   *
	   * @name eiti.format.transform
	   * @function
	   *
	   * @param {String|Function} format
	   * @param {Function} transform
	   * @return {Function}
	   */
	  eiti.format.transform = function(format, transform) {
	    format = eiti.format(format);
	    return function(d) {
	      return transform(format(d) || '');
	    };
	  };
	
	  eiti.format.percent = eiti.format('.1%');
	
	  /**
	   * Create a range formatter that strips the preceding `$`
	   * from the second value to produce strings like `$10m - 20m`
	   * instead of `$10m - $20m`.
	   * @name eiti.format.range
	   * @param {String|Function} format
	   * @param {String} [glue]
	   * @return {Function}
	   */
	  eiti.format.range = function(format, glue) {
	    format = eiti.format(format);
	    if (!glue) {
	      glue = ' – ';
	    }
	    return function(range) {
	      range = range.map(function(d, i) {
	        var str = format(d);
	        return i > 0 ? str.replace('$', '') : str;
	      });
	      /*
	      // suffix de-duping
	      var suffix = range.map(function(str) {
	        var match = str.match(/[a-z]$/);
	        return match ? match[0] : null;
	      });
	      if (suffix[0] === suffix[1]) {
	        range[0] = range[0].substr(0, range[0].length - 1);
	      }
	      */
	      return range.join(glue);
	    };
	  };
	
	  /**
	   * This is a format transform that turns metric/SI suffixes into more
	   * US-friendly ones: M -> m, G -> b, etc.
	   *
	   * @param {String} str the formatted string
	   * @return {String} the formatted string with replaced SI suffix
	   */
	  eiti.format.transformMetric = (function() {
	    var suffix = {k: 'k', M: 'm', G: 'b'};
	    return function(str) {
	      return str.replace(/(\.0+)?([kMG])$/, function(_, zeroes, s) {
	        return suffix[s] || s;
	      })
	      .replace(/\.0+$/, '');
	    };
	  })();
	
	  /**
	   * Produces international system ("SI")/metric form.
	   *
	   * @example
	   * assert.equal(eiti.format.is(4.2e6), '4.2m');
	   *
	   * @name eiti.format.si
	   * @function
	   *
	   * @param {Number} num
	   * @return {String}
	   */
	  eiti.format.si = eiti.format.transform('.2s', eiti.format.transformMetric);
	
	  eiti.format.transformDollars = function(str) {
	    if (str.charAt(0) === '-') {
	      str = '(' + str.substr(1) + ')';
	    }
	    return '$' + str;
	  };
	
	  /**
	   * Produces whole dollar strings in SI/metric form, prefixed
	   * with a '$', and negative numbers in parentheses.
	   *
	   * @name eiti.format.dollars
	   * @function
	   *
	   * @param {Number} num
	   * @return {String}
	   */
	  eiti.format.dollars = eiti.format.transform(
	    eiti.format.si,
	    eiti.format.transformDollars
	  );
	
	  /**
	   * Produces dollar strings with thousands separators and 2-decimal
	   * cents, e.g. `$1,234,567.89`.
	   *
	   * @name eiti.format.dollarsAndCents
	   * @function
	   *
	   * @param {Number} num
	   * @return {String}
	   */
	  eiti.format.dollarsAndCents = eiti.format.transform(
	    ',.2f',
	    eiti.format.transformDollars
	  );
	
	  /**
	   * Produces short dollar strings in SI format with 1 decimal,
	   * e.g. `$1.2m` or `$4.8b`.
	   * @name eiti.format.shortDollars
	   * @function
	   * @param {Number} num
	   * @return {String}
	   */
	  eiti.format.shortDollars = eiti.format.transform(
	    '$,.2s', eiti.format.transformMetric
	  );
	
	  eiti.format.pluralize = function(num, singular, plural) {
	    return (num === 1)
	      ? singular
	      : plural || singular + 's';
	  };
	
	  function getter(key) {
	    if (typeof key === 'function') {
	      return key;
	    }
	    return function(d) {
	      return d[key];
	    };
	  }
	
	  /*
	   * This is a d3 helper that allows you to toggle multiple classes
	   * *when used with `d3.selection#classed`*. You do *not* need this
	   * otherwise.
	   */
	  function classify(_add, _remove) {
	    var add = [];
	    var remove = [];
	
	    var classify = function() { // jshint ignore:line
	      var classes = this.classList;
	      if (add && add.length) {
	        add.forEach(function(klass) {
	          classes.add(klass);
	        });
	      }
	      if (remove && remove.length) {
	        remove.forEach(function(klass) {
	          classes.remove(klass);
	        });
	      }
	      return this.className;
	    };
	
	    classify.add = function(_) {
	      if (!arguments.length) {
	        return add;
	      }
	      add = Array.isArray(_) ? _ : [_];
	      return classify;
	    };
	
	    classify.remove = function(_) {
	      if (!arguments.length) {
	        return remove;
	      }
	      remove = Array.isArray(_) ? _ : [_];
	      return classify;
	    };
	
	    return classify
	      .add(_add)
	      .remove(_remove);
	  }
	
	
	  /**
	   * URL mutation
	   */
	
	  eiti.url = {};
	
	  eiti.url.merge = function(href, data) {
	    return eiti.url.qs.merge(href, data);
	  };
	
	  eiti.url.qs = (function() {
	
	    var qs = function(data) {
	      return typeof data === 'string' ? qs.parse(data) : data || {};
	    };
	
	    // strings that are typically okay to include in the hash
	    qs.replacements = {
	      '%20': '+',
	      '%2C': ','
	    };
	
	    qs.encode = function(val) {
	      var replace = qs.replacements;
	      return encodeURIComponent(val)
	        .replace(/(\%[A-F0-9]{2})/g, function(_, hex) {
	          return hex in replace
	            ? replace[hex]
	            : hex;
	        });
	    };
	
	    qs.decode = function(str) {
	      return decodeURIComponent(str.replace(/\+/g, ' '));
	    };
	
	    // querystring.parse('?foo=a&baz=1') -> {foo: 'a', baz: 1}
	    qs.parse = function(str, separator) {
	      if (str.charAt(0) === '?') {
	        str = str.substr(1);
	      }
	
	      var query = {};
	      forEach(str.split(separator || '&'), function(bit) {
	        var parts = bit.split('=', 2),
	            key = qs.decode(parts[0]),
	            value = parts.length > 1
	              ? qs.decode(parts[1])
	              : true;
	        switch (value) {
	          case 'true':
	            value = true;
	            break;
	          case 'false':
	            value = false;
	            break;
	          case '':
	            break;
	          default:
	            var num = +value;
	            if (!isNaN(num)) {
	              value = num;
	            }
	        }
	        query[key] = value;
	      });
	
	      return query;
	    };
	
	    // querystring.format({foo: 'a', baz: 1}) -> '?foo=a&baz=1'
	    qs.format = function(obj, separator, sortKeys) {
	      var entries = [];
	      for (var key in obj) { /* jshint -W089 */
	        var value = obj[key];
	        if (obj.hasOwnProperty(key) &&
	            (typeof value !== 'undefined') && value !== '') {
	          entries.push({key: key, value: String(obj[key])});
	        }
	      }
	      if (sortKeys) {
	        entries.sort(function(a, b) {
	          return a.key > b.key ? 1 : a.key < b.key ? -1 : 0;
	        });
	      }
	      return entries.length
	        ? entries.map(function(e) {
	            return [qs.encode(e.key), qs.encode(e.value)].join('=');
	          }).join(separator || '&')
	        : '';
	    };
	
	    qs.merge = function(url, data) {
	      var bits = url.split('?');
	      var query;
	      // if there's a query string...
	      if (bits.length > 1) {
	        query = qs.parse(bits[1]);
	        if (typeof data === 'string') {
	          data = qs.parse(data);
	        }
	        for (var key in data) { /* jshint -W089 */
	          query[key] = data[key];
	        }
	        query = qs.format(query);
	      } else {
	        query = (typeof data === 'string')
	          ? data
	          : qs.format(data);
	      }
	      return query ? [bits[0], query].join('?') : bits[0];
	    };
	
	    return qs;
	  })();
	
	  function forEach(list, fn, context) {
	    return Array.prototype.forEach.call(list, fn, context);
	  }
	
	
	  /**
	   * CustomEvent polyfill via:
	   * <https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent>
	   */
	  (function () {
	    try {
	      var e = new CustomEvent('foo'); // jshint ignore:line
	    } catch (error) {
	      function CustomEvent(event, params) {
	        params = params || {
	          bubbles: false,
	          cancelable: false,
	          detail: undefined
	        };
	        var evt = document.createEvent('CustomEvent');
	        evt.initCustomEvent(event, params.bubbles,
	                            params.cancelable, params.detail);
	        return evt;
	      }
	      CustomEvent.prototype = window.Event.prototype;
	      window.CustomEvent = CustomEvent;
	    }
	  })();
	
	
	  /**
	   * DOMTokenList::toggle() fix
	   *
	   * This addresses a bug in IE10+ in which DOMTokenList::toggle()
	   * doesn't respect the second argument, but just flips the class.
	   */
	  (function() {
	    var el = document.createElement('div');
	    el.classList.toggle('foo', false);
	    if (el.className === 'foo') {
	      DOMTokenList.prototype.toggle = function(klass, active) {
	        return this[active ? 'add' : 'remove'](klass);
	      };
	    }
	  })();
	
	})(this);
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8)))

/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }
/******/ ]);
//# sourceMappingURL=bundle.min.js.map